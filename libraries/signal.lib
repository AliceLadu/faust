//#################################### signal.lib ########################################
// A library of basic elements to handle signals in Faust.
//
// It should be used using the `si` environment:
//
// ```
// si = library("signal.lib");
// process = si.functionCall;
// ```
//
// Another option is to import `stdfaust.lib` which already contains the `si`
// environment:
//
// ```
// import("stdfaust.lib");
// process = si.functionCall;
// ```
//########################################################################################

/************************************************************************
************************************************************************
FAUST library file
Copyright (C) 2003-2016 GRAME, Centre National de Creation Musicale
----------------------------------------------------------------------
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as
published by the Free Software Foundation; either version 2.1 of the
License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public
License along with the GNU C Library; if not, write to the Free
Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
02111-1307 USA.

EXCEPTION TO THE LGPL LICENSE : As a special exception, you may create a
larger FAUST program which directly or indirectly imports this library
file and still distribute the compiled code generated by the FAUST
compiler, or a modified version of this compiled code, under your own
copyright and license. This EXCEPTION TO THE LGPL LICENSE explicitly
grants you the right to freely choose the license for the resulting
compiled code. In particular the resulting compiled code has no obligation
to be LGPL or GPL. For example you are free to choose a commercial or
closed source license or any other license if you decide so.
************************************************************************
************************************************************************/

import("stdfaust.lib");

//ba = library("basic.lib");

declare name "Faust Signal Handling Library";
declare version "0.0";

//=============================Functions Reference========================================
//========================================================================================


//--------------------------------`bus(n)`-------------------------------------
// n parallel cables
//
// #### Usage
//
// ```
// bus(4) -> _,_,_,_
// ```
//
// Where:
//
// * `n`: is an integer known at compile time that indicates the number of parallel cables.
//-----------------------------------------------------------------------------
bus(2) = _,_; // avoids a lot of "bus(1)" labels in block diagrams
bus(n) = par(i, n, _);


//--------------`block(n)`--------------
// Block - terminate n signals.
//
// #### Usage
//
// ```
// _,_,... : block(n) : _,...
// ```
//
// Where:
//
// * `n`: the number of signals to be blocked
//--------------------------------------
block(n) = par(i,n,!);


//--------------------------------`cross(n)`-----------------------------------
// Cross n signals: `(x1,x2,..,xn) -> (xn,..,x2,x1)`.
//
// #### Usage
//
// ```
// _,_,_ : cross(3) : _,_,_
// ```
//
// Where:
//
// * `n`: number of signals (int, must be known at compile time)
//
// #### Note
//
// Special case: `cross2`:
//
// ```
// cross2 = _,cross(2),_;
// ```
//-----------------------------------------------------------------------------
// cross n cables : (x1,x2,..,xn) -> (xn,..,x2,x1)
cross(n) = bus(n) <: par(i,n,ba.selector(n-i-1,n));
cross2 = _,cross(2),_; // for compatibility with some old effect.lib functions


//--------------`crossnn(n)`--------------
// Cross two `bus(n)`s.
//
// #### Usage
//
// ```
// _,_,... : crossmm(n) : _,_,...
// ```
//
// Where:
//
// * `n`: the number of signals in the `bus`
//--------------------------------------
crossnn(n) = bus(n),bus(n) <: block(n),bus(n),bus(n),block(n);


//--------------`crossn1(n)`--------------
// Cross bus(n) and bus(1).
//
// #### Usage
//
// ```
// _,_,... : crossn1(n) : _,_,...
// ```
//
// Where:
//
// * `n`: the number of signals in the first `bus`
//--------------------------------------
crossn1(n) = bus(n),(bus(1)<:bus(n)) <: block(n),bus(n),bus(n),block(n):bus(1),block(n-1),bus(n);


//-----------------------------`interpolate(i)`-------------------------------
// Linear interpolation between two signals.
//
// #### Usage
//
// ```
// _,_ : interpolate(i) : _
// ```
//
// Where:
//
// * `i`: interpolation control between 0 and 1 (0: first input; 1: second input)
//-----------------------------------------------------------------------------
interpolate(i) = *(1.0-i),*(i) : +;


//-------------------`smooth(s)`-----------------------------------
// Exponential smoothing by a unity-dc-gain one-pole lowpass.
//
// #### Usage: 
//
// ```
// _ : smooth(tau2pole(tau)) : _
// ```
//
// Where: 
//
// * `tau`: desired smoothing time constant in seconds, or
//
// ```
// hslider(...) : smooth(s) : _ 
// ```
//
// Where: 
//
// * `s`: smoothness between 0 and 1. s=0 for no smoothing, s=0.999 is "very smooth",
// s>1 is unstable, and s=1 yields the zero signal for all inputs.
// The exponential time-constant is approximately 1/(1-s) samples, when s is close to 
// (but less than) 1.
//
// #### Reference: 
//
// <https://ccrma.stanford.edu/~jos/mdft/Convolution_Example_2_ADSR.html>
//-------------------------------------------------------------
// TODO: author: JOS, revised by RM
smooth(s) = *(1.0 - s) : + ~ *(s);


//------------------------`smoo`---------------------------------------
// Smoothing function based on `smooth` ideal to smooth UI signals 
// (sliders, etc.) down. 
//
// #### Usage
//
// ```
// hslider(...) : smoo;
// ```
//---------------------------------------------------------------------
smoo = smooth(0.999);


//-----------------------`polySmooth`--------------------------------
// A smoothing function based on `smooth` that doesn't smooth when a
// trigger signal is given. This is very useful when making 
// polyphonic synthesizer to make sure that the value of the parameter
// is the right one when the note is started.
//
// #### Usage
//
// ```
// hslider(...) : polysmooth(g,s,d) : _
// ```
//
// Where:
//
// * `g`: the gate/trigger signal used when making polyphonic synths
// * `s`: the smoothness (see `smooth`)
// * `d`: the number of samples to wait before the signal start being
// 		smoothed after `g` switched to 1
//-------------------------------------------------------------------
polySmooth(g,s,d) = smooth(s*((g==(g@d)) | (g == 0)));


//-----------------------------`bsmooth`------------------------------
// Block smooth linear interpolation during a block of samples.
//
// #### Usage
//
// ```
// hslider(...) : bsmooth : _
// ```
//-----------------------------------------------------------------------
bsmooth(c) = +(i) ~ _
with { 
	i = (c-c@n)/n;
	n = min(4096, max(1, fvariable(int count, <math.h>)));
};


//-------------`lag_ud(up, dn, signal)`---------------
// Lag filter with separate times for up and down.
//
// #### Usage
//
// ```
// _ : lag_ud(up, dn, signal) : _;
// ```
//----------------------------------------------------
// TODO: author Jonatan Liljedahl, revised by RM
lag_ud(up,dn) = _ <: ((>,ba.tau2pole(up),ba.tau2pole(dn):select2),_:smooth) ~ _;



//--------------------------`interleave(row,col)`------------------------------
// Interleave row*col cables from column order to row order.
// input : x(0), x(1), x(2) ..., x(row*col-1)
// output: x(0+0*row), x(0+1*row), x(0+2*row), ..., x(1+0*row), x(1+1*row), x(1+2*row), ...
//
// #### Usage
//
// ```
// _,_,_,_,_,_ : interleave(3,2) : _,_,_,_,_,_
// ```
//
// Where:
//
// * `row`: the number of row (int, known at compile time)
// * `column`: the number of column (int, known at compile time)
//-----------------------------------------------------------------------------
interleave(row,col) = bus(row*col) <: par(r, row, par(c, col, ba.selector(r+c*row,row*col)));


//-------------------------------`butterfly(n)`--------------------------------
// Addition (first half) then substraction (second half) of interleaved signals.
//
// #### Usage
//
// ```
// _,_,_,_ : butterfly(4) : _,_,_,_
// ```
//
// Where:
//
// * `n`: size of the butterfly (n is int, even and known at compile time)
//-----------------------------------------------------------------------------
butterfly(n) = bus(n) <: interleave(n/2,2), interleave(n/2,2) : par(i, n/2, +), par(i, n/2, -);


//------------------------------`hadamard(n)`----------------------------------
// Hadamard matrix function of size `n = 2^k`.
//
// #### Usage
//
// ```
// _,_,_,_ : hadamard(4) : _,_,_,_
// ```
//
// Where:
//
// * `n`: `2^k`, size of the matrix (int, must be known at compile time)
//
// #### Note:
//
// Implementation contributed by Remy Muller.
//-----------------------------------------------------------------------------
// TODO: author: Remy Muller, revised by RM
hadamard(2) = butterfly(2);
hadamard(n) = butterfly(n) : (hadamard(n/2) , hadamard(n/2));


//-------------------------------`dot(n)`--------------------------------------
// Dot product for two vectors of size n.
//
// #### Usage
//
// ```
// _,_,_,_,_,_ : dot(3) : _
// ```
//
// Where:
//
// * `n`: size of the vectors (int, must be known at compile time)
//-----------------------------------------------------------------------------
dot(n) = interleave(n,2) : par(i,n,*) :> _;


//------------------peakhold(mode,sig)---------------------------
// Outputs current max value above zero. 
//
// #### Usage
//
// ```
// _ : peakhold(mode,sig) : _;
// ```
//
// Where:
//
// `mode` means: 0 - Pass through. A single sample 0 trigger will work as a reset.
//    1 - Track and hold max value.
//----------------------------------------------------------------
// TODO: author Jonatan Liljedahl, revised by RM
peakhold = (*,_:max) ~ _;


//------------------peakholder(holdtime)---------------------------
// Tracks abs peak and holds peak for 'holdtime' samples.
//
// #### Usage 
//
// ```
// peakholder(holdtime, sig);
// ```
//----------------------------------------------------------------
// TODO: author Jonatan Liljedahl
peakholder(holdtime) = peakhold2 ~ reset : (!,_) with {
    reset = ba.sweep(holdtime) > 0;
    // first out is gate that is 1 while holding last peak
    peakhold2 = _,abs <: peakhold,!,_ <: >=,_,!;
};


//------------------`diffn(x)`----------------------------
// Negated first-roder difference.
//
// #### Usage
//
// ```
// _ : diffn : _
// ```
//--------------------------------------------------------
// TODO: author JOS, revised by RM
diffn(x) = x' - x; // negated first-order difference


//---------------`recursivize(p,q)`-------------
// Create a recursion from two arbitrary processors p and q.
//
// #### Usage
//
// ```
// _,_ : stereoize(p,q) : _,_
//
// ```
//
// Where:
//
// * `p`: the forward arbitrary processor
// * `q`: the feedback arbitrary processor
//----------------------------------------
recursivize(p,q) = (_,_,_,_ :> stereoize(p)) ~ stereoize(q);

