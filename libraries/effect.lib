//################################## effect.lib ##########################################
// This library contains a collection of audio effects.
//
// It should be used using the `ef` environment:
//
// ```
// ef = library("effect.lib");
// process = ef.functionCall;
// ```
//
// Another option is to import `stdfaust.lib` which already contains the `ef`
// environment:
//
// ```
// import("stdfaust.lib");
// process = ef.functionCall;
// ```
//########################################################################################

/************************************************************************
************************************************************************
FAUST library file
Copyright (C) 2003-2016 GRAME, Centre National de Creation Musicale
----------------------------------------------------------------------
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as
published by the Free Software Foundation; either version 2.1 of the
License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public
License along with the GNU C Library; if not, write to the Free
Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
02111-1307 USA.

EXCEPTION TO THE LGPL LICENSE : As a special exception, you may create a
larger FAUST program which directly or indirectly imports this library
file and still distribute the compiled code generated by the FAUST
compiler, or a modified version of this compiled code, under your own
copyright and license. This EXCEPTION TO THE LGPL LICENSE explicitly
grants you the right to freely choose the license for the resulting
compiled code. In particular the resulting compiled code has no obligation
to be LGPL or GPL. For example you are free to choose a commercial or
closed source license or any other license if you decide so.
************************************************************************
************************************************************************/

import("stdfaust.lib");

declare name "Faust Math Library";
declare version "2.0"; // TODO to check

//======================================Dynamic===========================================
//========================================================================================

//----------------------`levelfilter` and `levelfilterN`----------------------
// Dynamic level lowpass filter.
//
// #### Usage
//
// ```
// _ : levelfilter(L,freq) : _
// _ : levelfilterN(N,freq,L) : _
// ```
//
// Where:
//
// * `L`: desired level (in dB) at Nyquist limit (SR/2), e.g., -60
// * `freq`: corner frequency (-3dB point) usually set to fundamental freq
// * `N`: Number of filters in series where L = L/N
//
// #### Reference
//
// <https://ccrma.stanford.edu/realsimple/faust_strings/Dynamic_Level_Lowpass_Filter.html>
//------------------------------------------------------------
// TODO: author JOS, revised by RM
levelfilter(L,freq,x) = (L * L0 * x) + ((1.0-L) * lp2out(x))
with {
  L0 = pow(L,1/3);
  Lw = ma.PI*freq/ma.SR; // = w1 T / 2
  Lgain = Lw / (1.0 + Lw);
  Lpole2 = (1.0 - Lw) / (1.0 + Lw);
  lp2out = *(Lgain) : + ~ *(Lpole2);
};
levelfilterN(N,freq,L) = seq(i,N,levelfilter((L/N),freq));


//---------------------`cubicnl(drive,offset)`-----------------------
// Cubic nonlinearity distortion.
//
// #### Usage:
//
// ```
// _ : cubicnl(drive,offset) : _
// _ : cubicnl_nodc(drive,offset) : _
// ```
//
// Where:
//
// * `drive`: distortion amount, between 0 and 1
// * `offset`: constant added before nonlinearity to give even harmonics. Note: offset 
// 	can introduce a nonzero mean - feed cubicnl output to dcblocker to remove this.
//
// #### References:
//
// * <https://ccrma.stanford.edu/~jos/pasp/Cubic_Soft_Clipper.html>
// * <https://ccrma.stanford.edu/~jos/pasp/Nonlinear_Distortion.html>
//------------------------------------------------------------
// TODO: author JOS, revised by RM
cubicnl(drive,offset) = *(pregain) : +(offset) : clip(-1,1) : cubic
with {
    pregain = pow(10.0,2*drive);
    clip(lo,hi) = min(hi) : max(lo);
    cubic(x) = x - x*x*x/3;
    postgain = max(1.0,1.0/pregain);
};

cubicnl_nodc(drive,offset) = cubicnl(drive,offset) : fi.dcblocker;


//-----------------`gate_mono` and `gate_stereo`-------------------
// Mono and stereo signal gates.
//
// #### Usage
//
// ```
// _ : gate_mono(thresh,att,hold,rel) : _
// ```
//
// or
//
// ```
//  _,_ : gate_stereo(thresh,att,hold,rel) : _,_
// ```
//
// Where:
//
// * `thresh`: dB level threshold above which gate opens (e.g., -60 dB)
// * `att`: attack time = time constant (sec) for gate to open (e.g., 0.0001 s = 0.1 ms)
// * `hold`: hold time = time (sec) gate stays open after signal level < thresh (e.g., 0.1 s)
// * `rel`: release time = time constant (sec) for gate to close (e.g., 0.020 s = 20 ms)
//
// #### References
//
// * <http://en.wikipedia.org/wiki/Noise_gate>
// * <http://www.soundonsound.com/sos/apr01/articles/advanced.asp>
// * <http://en.wikipedia.org/wiki/Gating_(sound_engineering)>
//------------------------------------------------------------
// TODO: author JOS, revised by RM
gate_mono(thresh,att,hold,rel,x) = x * gate_gain_mono(thresh,att,hold,rel,x);

gate_stereo(thresh,att,hold,rel,x,y) = ggm*x, ggm*y with {
  ggm = gate_gain_mono(thresh,att,hold,rel,abs(x)+abs(y));
};

gate_gain_mono(thresh,att,hold,rel,x) = x : extendedrawgate : an.amp_follower_ar(att,rel) with {
  extendedrawgate(x) = max(float(rawgatesig(x)),holdsig(x));
  rawgatesig(x) = inlevel(x) > ba.db2linear(thresh);
  minrate = min(att,rel);
  inlevel = an.amp_follower_ar(minrate,minrate);
  holdcounter(x) = (max(holdreset(x) * holdsamps,_) ~-(1));
  holdsig(x) = holdcounter(x) > 0;
  holdreset(x) = rawgatesig(x) < rawgatesig(x)'; // reset hold when raw gate falls
  holdsamps = int(hold*ma.SR);
};


//--------------------`compressor_mono` and `compressor_stereo`-------------------
// Mono and stereo dynamic range compressors.
//
// #### Usage
//
// ```
// _ : compressor_mono(ratio,thresh,att,rel) : _
// _,_ : compressor_stereo(ratio,thresh,att,rel) : _,_
// ```
//
// Where:
//
// * `ratio`: compression ratio (1 = no compression, >1 means compression)
// * `thresh`: dB level threshold above which compression kicks in (0 dB = max level)
// * `att`: attack time = time constant (sec) when level & compression going up
// * `rel`: release time = time constant (sec) coming out of compression
//
// #### References
//
// * <http://en.wikipedia.org/wiki/Dynamic_range_compression>
// * <https://ccrma.stanford.edu/~jos/filters/Nonlinear_Filter_Example_Dynamic.html>
// * Albert Graef's "faust2pd"/examples/synth/compressor_.dsp
// * More features: <https://github.com/magnetophon/faustCompressors>
//------------------------------------------------------------
// TODO: author JOS, revised by RM
compressor_mono(ratio,thresh,att,rel,x) = x * compression_gain_mono(ratio,thresh,att,rel,x);

compressor_stereo(ratio,thresh,att,rel,x,y) = cgm*x, cgm*y with {
  cgm = compression_gain_mono(ratio,thresh,att,rel,abs(x)+abs(y));
};

compression_gain_mono(ratio,thresh,att,rel) =
  an.amp_follower_ar(att,rel) : ba.linear2db : outminusindb(ratio,thresh) :
  kneesmooth(att) : ba.db2linear
with {
  // kneesmooth(att) installs a "knee" in the dynamic-range compression,
  // where knee smoothness is set equal to half that of the compression-attack.
  // A general 'knee' parameter could be used instead of tying it to att/2:
  kneesmooth(att)  = si.smooth(ba.tau2pole(att/2.0));
  // compression gain in dB:
   outminusindb(ratio,thresh,level) = max(level-thresh,0.0) * (1.0/float(ratio)-1.0);
  // Note: "float(ratio)" REQUIRED when ratio is an integer > 1!
};


//-------------------------------`limiter_*`------------------------------------
// A limiter guards against hard-clipping.  It can be can be
// implemented as a compressor having a high threshold (near the
// clipping level), fast attack and release, and high ratio.  Since
// the ratio is so high, some knee smoothing is
// desirable ("soft limiting").  This example is intended
// to get you started using compressor_* as a limiter, so all
// parameters are hardwired to nominal values here.
// Ratios: 4 (moderate compression), 8 (severe compression),
//          12 (mild limiting), or 20 to 1 (hard limiting)
//   Att: 20-800 MICROseconds (Note: scaled by ratio in the 1176)
//   Rel: 50-1100 ms (Note: scaled by ratio in the 1176)
//   Mike Shipley likes 4:1 (Grammy-winning mixer for Queen, Tom Petty, etc.)
//     Faster attack gives "more bite" (e.g. on vocals)
//     He hears a bright, clear eq effect as well (not implemented here)
//
// #### Usage
//
// ```
//  _ : limiter_1176_R4_mono   : _;
//  _,_ : limiter_1176_R4_stereo : _,_;
// ```
//
// #### Reference:
//
// <http://en.wikipedia.org/wiki/1176_Peak_Limiter>
//------------------------------------------------------------
// TODO: author JOS, revised by RM
limiter_1176_R4_mono = compressor_mono(4,-6,0.0008,0.5);
limiter_1176_R4_stereo = compressor_stereo(4,-6,0.0008,0.5);


//=====================================Filtering==========================================
//========================================================================================

//-------------------------`speakerbp(f1,f2)`-------------------------------
// Dirt-simple speaker simulator (overall bandpass eq with observed
// roll-offs above and below the passband).
//
// Low-frequency speaker model = +12 dB/octave slope breaking to
// flat near f1. Implemented using two dc blockers in series.
//
// High-frequency model = -24 dB/octave slope implemented using a
// fourth-order Butterworth lowpass.
//
// Example based on measured Celestion G12 (12" speaker):
// speakerbp(130,5000);
//
// #### Usage
// 
// ```
// _ : speakerbp(130,5000) : _
// ```
//------------------------------------------------------------
// TODO: author JOS, revised by RM
// TODO: perhaps this should be moved to pm.lib
speakerbp(f1,f2) = fi.dcblockerat(f1) : fi.dcblockerat(f1) : fi.lowpass(4,f2);


//-------------------------`moog_vcf(res,fr)`---------------------------
// Moog "Voltage Controlled Filter" (VCF) in "analog" form. Moog VCF 
// implemented using the same logical block diagram as the classic 
// analog circuit.  As such, it neglects the one-sample delay associated 
// with the feedback path around the four one-poles.
// This extra delay alters the response, especially at high frequencies
// (see reference [1] for details).
// See `moog_vcf_2b` below for a more accurate implementation.
//
// #### Usage
//
// ```
// moog_vcf(res,fr)
// ```
// Where:
//
// * `fr`: corner-resonance frequency in Hz ( less than SR/6.3 or so )
// * `res`: Normalized amount of corner-resonance between 0 and 1 (0 is no 
// 	resonance, 1 is maximum)
//
// #### References
// * <https://ccrma.stanford.edu/~stilti/papers/moogvcf.pdf>
// * <https://ccrma.stanford.edu/~jos/pasp/vegf.html>
//------------------------------------------------------------
// TODO: author JOS, revised by RM
moog_vcf(res,fr) = (+ : seq(i,4,fi.pole(p)) : *(unitygain(p))) ~ *(mk)
with {
     p = 1.0 - fr * 2.0 * ma.PI / ma.SR; // good approximation for fr << SR
     unitygain(p) = pow(1.0-p,4.0); // one-pole unity-gain scaling
     mk = -4.0*max(0,min(res,0.999999)); // need mk > -4 for stability
};

//-----------------------`moog_vcf_2b[n]`---------------------------
// Moog "Voltage Controlled Filter" (VCF) as two biquads. Implementation 
// of the ideal Moog VCF transfer function factored into second-order 
// sections. As a result, it is more accurate than moog_vcf above, but 
// its coefficient formulas are more complex when one or both parameters 
// are varied.  Here, res is the fourth root of that in moog_vcf, so, as 
// the sampling rate approaches infinity, moog_vcf(res,fr) becomes equivalent
// to moog_vcf_2b[n](res^4,fr) (when res and fr are constant).
// `moog_vcf_2b` uses two direct-form biquads (`tf2`).
// `moog_vcf_2bn` uses two protected normalized-ladder biquads (`tf2np`).
//
// #### Usage
//
// ```
// moog_vcf_2b(res,fr)
// moog_vcf_2bn(res,fr)
// ```
//
// Where:
//
// * `fr`: corner-resonance frequency in Hz
// * `res`: Normalized amount of corner-resonance between 0 and 1
// 	(0 is min resonance, 1 is maximum)
//------------------------------------------------------------
// TODO: author JOS, revised by RM
moog_vcf_2b(res,fr) = fi.tf2s(0,0,b0,a11,a01,w1) : fi.tf2s(0,0,b0,a12,a02,w1)
with {
 s = 1; // minus the open-loop location of all four poles
 frl = max(20,min(10000,fr)); // limit fr to reasonable 20-10k Hz range
 w1 = 2*ma.PI*frl; // frequency-scaling parameter for bilinear xform
 // Equivalent: w1 = 1; s = 2*PI*frl;
 kmax = sqrt(2)*0.999; // 0.999 gives stability margin (tf2 is unprotected)
 k = min(kmax,sqrt(2)*res); // fourth root of Moog VCF feedback gain
 b0 = s^2;
 s2k = sqrt(2) * k;
 a11 = s * (2 + s2k);
 a12 = s * (2 - s2k);
 a01 = b0 * (1 + s2k + k^2);
 a02 = b0 * (1 - s2k + k^2);
};

moog_vcf_2bn(res,fr) = fi.tf2snp(0,0,b0,a11,a01,w1) : fi.tf2snp(0,0,b0,a12,a02,w1)
with {
 s = 1; // minus the open-loop location of all four poles
 w1 = 2*ma.PI*max(fr,20); // frequency-scaling parameter for bilinear xform
 k = sqrt(2)*0.999*res; // fourth root of Moog VCF feedback gain
 b0 = s^2;
 s2k = sqrt(2) * k;
 a11 = s * (2 + s2k);
 a12 = s * (2 - s2k);
 a01 = b0 * (1 + s2k + k^2);
 a02 = b0 * (1 - s2k + k^2);
};


//--------------------------`wah4(fr)`-------------------------------
// Wah effect, 4th order.
//
// #### Usage
//
// ```
// _ : wah4(fr) : _
// ```
//
// Where: 
//
// * `fr`: resonance frequency in Hz
//
// #### Reference
//
// <https://ccrma.stanford.edu/~jos/pasp/vegf.html>
//------------------------------------------------------------
// TODO: author JOS, revised by RM
wah4(fr) = 4*moog_vcf((3.2/4),fr:si.smooth(0.999));


//------------------------`autowah(level)`-----------------------------
// Auto-wah effect.
//
// #### Usage
//
// ```
// _ : autowah(level) : _;
// ```
//
// Where: 
//
// * `level`: amount of effect desired (0 to 1).
//------------------------------------------------------------
// TODO: author JOS, revised by RM
autowah(level,x) = level * crybaby(an.amp_follower(0.1,x),x) + (1.0-level)*x;


//--------------------------`crybaby(wah)`-----------------------------
// Digitized CryBaby wah pedal.
//
// #### Usage
//
// ```
// _ : crybaby(wah) : _
// ```
//
// Where: 
//
// * `wah`: "pedal angle" from 0 to 1
//
// #### Reference
//
// <https://ccrma.stanford.edu/~jos/pasp/vegf.html>
//------------------------------------------------------------
// TODO: author JOS, revised by RM
crybaby(wah) = *(gs) : fi.tf2(1,-1,0,a1s,a2s)
with {
  Q  = pow(2.0,(2.0*(1.0-wah)+1.0)); // Resonance "quality factor"
  fr = 450.0*pow(2.0,2.3*wah);       // Resonance tuning
  g  = 0.1*pow(4.0,wah);             // gain (optional)

  // Biquad fit using z = exp(s T) ~ 1 + sT for low frequencies:
  frn = fr/ma.SR; // Normalized pole frequency (cycles per sample)
  R = 1 - ma.PI*frn/Q; // pole radius
  theta = 2*ma.PI*frn; // pole angle
  a1 = 0-2.0*R*cos(theta); // biquad coeff
  a2 = R*R;                // biquad coeff

  // dezippering of slider-driven signals:
  s = 0.999; // smoothing parameter (one-pole pole location)
  a1s = a1 : si.smooth(s);
  a2s = a2 : si.smooth(s);
  gs =  g  : si.smooth(s);

  //tf2 = component("filter.lib").tf2;
};


//------------`piano_dispersion_filter(M,B,f0)`---------------
// Piano dispersion allpass filter in closed form.
//
// #### Usage
//
// ```
// _ : piano_dispersion_filter(1,B,f0) : +(totalDelay),_ : fdelay(maxDelay) : _
// ```
//
// Where:
//
// * `M`: number of first-order allpass sections (compile-time only)
//  	Keep below 20. 8 is typical for medium-sized piano strings.
// * `B`: string inharmonicity coefficient (0.0001 is typical)
// * `f0`: fundamental frequency in Hz
//
// #### Outputs
//
// * MINUS the estimated delay at `f0` of allpass chain in samples,
//     provided in negative form to facilitate subtraction
//     from delay-line length.
// * Output signal from allpass chain

// #### Reference
//
// * "Dispersion Modeling in Waveguide Piano Synthesis Using Tunable 
// Allpass Filters", by Jukka Rauhala and Vesa Valimaki, DAFX-2006, pp. 71-76
// * <http://www.dafx.ca/proceedings/papers/p_071.pdf> (An erratum in Eq. (7) 
// 		is corrected in Dr. Rauhala's encompassing dissertation (and below).)
// * <http://www.acoustics.hut.fi/research/asp/piano/>
//------------------------------------------------------------
// TODO: author JOS, revised by RM
// TODO: perhaps this should be moved to pm.lib?
piano_dispersion_filter(M,B,f0) = -Df0*M,seq(i,M,fi.tf1(a1,1,a1))
with {
 a1 = (1-D)/(1+D); // By Eq. 3, have D >= 0, hence a1 >= 0 also
 D = exp(Cd - Ikey(f0)*kd);
 trt = pow(2.0,1.0/12.0); // 12th root of 2
 logb(b,x) = log(x) / log(b); // log-base-b of x
 Ikey(f0) = logb(trt,f0*trt/27.5);
 Bc = max(B,0.000001);
 kd = exp(k1*log(Bc)*log(Bc) + k2*log(Bc)+k3);
 Cd = exp((m1*log(M)+m2)*log(Bc)+m3*log(M)+m4);
 k1 = -0.00179;
 k2 = -0.0233;
 k3 = -2.93;
 m1 = 0.0126;
 m2 = 0.0606;
 m3 = -0.00825;
 m4 = 1.97;
 wT = 2*ma.PI*f0/ma.SR;
 polydel(a) = atan(sin(wT)/(a+cos(wT)))/wT;
 Df0 = polydel(a1) - polydel(1.0/a1);
};


//----------------------------`vocoder`-------------------------
// A very simple vocoder where the spectrum of the modulation signal
// is analyzed using a filter bank.
//
// #### Usage
//
// ```
// _ : vocoder(nBands,att,rel,BWRatio,source,excitation) : _;
// ```
//
// Where:
//
// * `nBands`: Number of vocoder bands
// * `att`: Attack time in seconds
// * `rel`: Release time in seconds
// * `BWRatio`: Coefficient to adjust the bandwidth of each band (0.1 - 2)
// * `source`: Modulation signal
// * `excitation`: Excitation/Carrier signal
//------------------------------------------------------------
// TODO: author RM
oneVocoderBand(band,bandsNumb,bwRatio,bandGain,x) = x : fi.resonbp(bandFreq,bandQ,bandGain) with{
        bandFreq = 25*pow(2,(band+1)*(9/bandsNumb));
        BW = (bandFreq - 25*pow(2,(band)*(9/bandsNumb)))*bwRatio;
        bandQ = bandFreq/BW;
};

vocoder(nBands,att,rel,BWRatio,source,excitation) = source <: par(i,nBands,oneVocoderBand(i,nBands,BWRatio,1) : an.amp_follower_ar(att,rel) : _,excitation : oneVocoderBand(i,nBands,BWRatio)) :> _ ;


//-------------------------`stereo_width(w)`---------------------------
// Stereo Width effect using the Blumlein Shuffler technique.
//
// #### Usage
//
// ```
// _,_ : stereo_width(w) : _,_
// ```
//
// Where:
//
// * `w`: stereo width between 0 and 1
//
// At `w=0`, the output signal is mono ((left+right)/2 in both channels).
// At `w=1`, there is no effect (original stereo image).
// Thus, w between 0 and 1 varies stereo width from 0 to "original".
//
// #### Reference
//
// * "Applications of Blumlein Shuffling to Stereo Microphone Techniques"
// Michael A. Gerzon, JAES vol. 42, no. 6, June 1994
//------------------------------------------------------------
// TODO: author JOS, revised by RM
stereo_width(w) = shuffle : *(mgain),*(sgain) : shuffle
with {
     shuffle =  _,_ <: +,-; // normally scaled by 1/sqrt(2) for orthonormality,
     mgain = 1-w/2;  // but we pick up the needed normalization here.
     sgain = w/2;
};

//=================================Phasing and Flanging===================================
//========================================================================================

//---------------`flanger_mono` and `flanger_stereo`-------------
// Flanging effect.
//
// #### Usage:
//
// ```
// _ : flanger_mono(dmax,curdel,depth,fb,invert) : _;
// _,_ : flanger_stereo(dmax,curdel1,curdel2,depth,fb,invert) : _,_;
// _,_ : flanger_demo : _,_;
// ```
//
// Where:
//
// * `dmax`: maximum delay-line length (power of 2) - 10 ms typical
// * `curdel`: current dynamic delay (not to exceed dmax)
// * `depth`: effect strength between 0 and 1 (1 typical)
// * `fb`: feedback gain between 0 and 1 (0 typical)
// * `invert`: 0 for normal, 1 to invert sign of flanging sum
//
// #### Reference
//
// <https://ccrma.stanford.edu/~jos/pasp/Flanging.html>
//------------------------------------------------------------
// TODO: author JOS, revised by RM
flanger_mono(dmax,curdel,depth,fb,invert)
  = _ <: _, (- : de.fdelay(dmax,curdel)) ~ *(fb) : _,
  *(select2(invert,depth,0-depth))
  : + : *(0.5);

flanger_stereo(dmax,curdel1,curdel2,depth,fb,invert)
  =  flanger_mono(dmax,curdel1,depth,fb,invert),
     flanger_mono(dmax,curdel2,depth,fb,invert);


//-------`phaser2_mono` and `phaser2_stereo`-------
// Phasing effect.
//
// #### Phaser
//
// ```
// _ : phaser2_mono(Notches,phase,width,frqmin,fratio,frqmax,speed,depth,fb,invert) : _;
// _,_ : phaser2_stereo(") : _,_;
// _,_ : phaser2_demo : _,_;
// ```
//
// Where:
//
// * `Notches`: number of spectral notches (MACRO ARGUMENT - not a signal)
// * `phase`: phase of the oscillator (0-1)
// * `width`: approximate width of spectral notches in Hz
// * `frqmin`: approximate minimum frequency of first spectral notch in Hz
// * `fratio`: ratio of adjacent notch frequencies
// * `frqmax`: approximate maximum frequency of first spectral notch in Hz
// * `speed`: LFO frequency in Hz (rate of periodic notch sweep cycles)
// * `depth`: effect strength between 0 and 1 (1 typical) (aka "intensity")
//            when depth=2, "vibrato mode" is obtained (pure allpass chain)
// * `fb`: feedback gain between -1 and 1 (0 typical)
// * `invert`: 0 for normal, 1 to invert sign of flanging sum
//
// Reference:
//
// * <https://ccrma.stanford.edu/~jos/pasp/Phasing.html>
// * <http://www.geofex.com/Article_Folders/phasers/phase.html>
// * 'An Allpass Approach to Digital Phasing and Flanging', Julius O. Smith III,
//		Proc. Int. Computer Music Conf. (ICMC-84), pp. 103-109, Paris, 1984.
// * CCRMA Tech. Report STAN-M-21: <https://ccrma.stanford.edu/STANM/stanms/stanm21/>
//------------------------------------------------------------
// TODO: author JOS, revised by RM
vibrato2_mono(sections,phase01,fb,width,frqmin,fratio,frqmax,speed) =
 (+ : seq(i,sections,ap2p(R,th(i)))) ~ *(fb)
with {
     //tf2 = component("filter.lib").tf2;
     // second-order resonant digital allpass given pole radius and angle:
     ap2p(R,th) = fi.tf2(a2,a1,1,a1,a2) with {
       a2 = R^2;
       a1 = -2*R*cos(th);
     };
     R = exp(-pi*width/ma.SR);
     cososc = ge.oscrc; // generator.lib
     sinosc = ge.oscrs; // generator.lib
     osc = cososc(speed) * phase01 + sinosc(speed) * (1-phase01);
     lfo = (1-osc)/2; // in [0,1]
     pi = 4*atan(1);
     thmin = 2*pi*frqmin/ma.SR;
     thmax = 2*pi*frqmax/ma.SR;
     th1 = thmin + (thmax-thmin)*lfo;
     th(i) = (fratio^(i+1))*th1;
};

phaser2_mono(Notches,phase01,width,frqmin,fratio,frqmax,speed,depth,fb,invert) =
      _ <: *(g1) + g2mi*vibrato2_mono(Notches,phase01,fb,width,frqmin,fratio,frqmax,speed)
with {               // depth=0 => direct-signal only
     g1 = 1-depth/2; // depth=1 => phaser mode (equal sum of direct and allpass-chain)
     g2 = depth/2;   // depth=2 => vibrato mode (allpass-chain signal only)
     g2mi = select2(invert,g2,-g2); // inversion negates the allpass-chain signal
};

phaser2_stereo(Notches,width,frqmin,fratio,frqmax,speed,depth,fb,invert)
   = phaser2_mono(Notches,0,width,frqmin,fratio,frqmax,speed,depth,fb,invert),
     phaser2_mono(Notches,1,width,frqmin,fratio,frqmax,speed,depth,fb,invert);


//========================================Time Based======================================
//========================================================================================

//----------`echo(maxDuration,duration,feedback)`----------
// A simple echo effect.
//
// #### Usage
//
// ```
// echo(maxDuration,duration,feedback)
// ```
//
// Where:
//
// * `maxDuration`: the max echo duration in seconds
// * `duration`: the echo duration in seconds
// * `feedback`: the feedback coefficient
//----------------------------------------------------
// TODO: author RM
// TODO: needs to be checked
echo(maxDuration,duration,feedback) = +~(de.fdelay1(N,n)*feedback)
with{
	N = maxDuration : ba.sec2samp : ma.np2; // compute the next power of 2 of maxDuration
	n = duration : ba.sec2samp;
};

// TODO demo function for echo

//=======================================Pitch Shifting===================================
//========================================================================================

//--------------`transpose`----------------
// A simple pitch shifter based on 2 delay lines.
// 
// #### Usage
//
// ```
// _ : transpose(w, x, s) : _
// ```
//
// Where:
//
// * `w`: the window length (samples)
// * `x`: crossfade duration duration (samples)
// * `s`: shift (semitones)
//-----------------------------------------
transpose(w, x, s, sig) = de.fdelay(maxDelay,d,sig)*ma.fmin(d/x,1) + 
	de.fdelay(maxDelay,d+w,sig)*(1-ma.fmin(d/x,1))
with {
	maxDelay = 65536;
	i = 1 - pow(2, s/12);
	d = i : (+ : +(w) : fmod(_,w)) ~ _;
};


//===========================================Reverbs======================================
//========================================================================================

//------------------------------`jcrev` and `satrev`------------------------------
// These artificial reverberators take a mono signal and output stereo
// (`satrev`) and quad (`jcrev`).  They were implemented by John Chowning
// in the MUS10 computer-music language (descended from Music V by Max
// Mathews).  They are Schroeder Reverberators, well tuned for their size.
// Nowadays, the more expensive freeverb is more commonly used (see the
// Faust examples directory).
//
// `jcrev` reverb below was made from a listing of "RV", dated April 14, 1972,
// which was recovered from an old SAIL DART backup tape.
// John Chowning thinks this might be the one that became the
// well known and often copied JCREV.
//
// `satrev` was made from a listing of "SATREV", dated May 15, 1971,
// which was recovered from an old SAIL DART backup tape.
// John Chowning thinks this might be the one used on his
// often-heard brass canon sound examples, one of which can be found at
// <https://ccrma.stanford.edu/~jos/wav/FM_BrassCanon2.wav>
//
// #### Usage
//
// ```
// _ : jcrev : _,_,_,_
// _ : satrev : _,_
// ```
//------------------------------------------------------------
// TODO: author JOS, revised by RM
jcrev = *(0.06) : allpass_chain <: comb_bank : mix_mtx with {
  rev1N = fi.rev1;
  rev12(len,g) = rev1N(2048,len,g);
  rev14(len,g) = rev1N(4096,len,g);
  allpass_chain =
    fi.rev2(512,347,0.7) :
    fi.rev2(128,113,0.7) :
    fi.rev2( 64, 37,0.7);
  comb_bank =
    rev12(1601,.802),
    rev12(1867,.773),
    rev14(2053,.753),
    rev14(2251,.733);
    mix_mtx = _,_,_,_ <: psum, -psum, asum, -asum : _,_,_,_ with {
    psum = _,_,_,_ :> _;
    asum = *(-1),_,*(-1),_ :> _;
  };
};

satrev = *(0.2) <: comb_bank :> allpass_chain <: _,*(-1) with {
  rev1N = fi.rev1;
  rev11(len,g) = rev1N(1024,len,g);
  rev12(len,g) = rev1N(2048,len,g);
  comb_bank =
    rev11( 778,.827),
    rev11( 901,.805),
    rev11(1011,.783),
    rev12(1123,.764);
  rev2N = fi.rev2;
  allpass_chain =
    rev2N(128,125,0.7) :
    rev2N( 64, 42,0.7) :
    rev2N( 16, 12,0.7);
};


//----------------------------`mono_freeverb` and `stereo_freeverb`-------------------------
// A simple Schroeder reverberator primarily developed by "Jezar at Dreampoint" that
// is extensively used in the free-software world. It uses four Schroeder allpasses in
// series and eight parallel Schroeder-Moorer filtered-feedback comb-filters for each
// audio channel, and is said to be especially well tuned.
//
// #### Usage
//
// ```
// _ : mono_freeverb(fb1, fb2, damp, spread) : _;
// _,_ : stereo_freeverb(fb1, fb2, damp, spread) : _,_;
// ```
//
// Where:
//
// * `fb1`: coefficient of the lowpass comb filters (0-1)
// * `fb2`: coefficient of the allpass comb filters (0-1)
// * `damp`: damping of the lowpass comb filter (0-1)
// * `spread`: spatial spread in number of samples (for stereo)
//------------------------------------------------------------
// TODO: author RM
mono_freeverb(fb1, fb2, damp, spread) = _ <: par(i,8,lbcf(combtuningL(i)+spread,fb1,damp)) 
	:> seq(i,4,fi.allpass_comb(1024, allpasstuningL(i)+spread, -fb2))
with{
    origSR = 44100;

    // Filters parameters
    combtuningL(0) = 1116*ma.SR/origSR : int;
    combtuningL(1) = 1188*ma.SR/origSR : int;
    combtuningL(2) = 1277*ma.SR/origSR : int;
    combtuningL(3) = 1356*ma.SR/origSR : int;
    combtuningL(4) = 1422*ma.SR/origSR : int;
    combtuningL(5) = 1491*ma.SR/origSR : int;
    combtuningL(6) = 1557*ma.SR/origSR : int;
    combtuningL(7) = 1617*ma.SR/origSR : int;

    allpasstuningL(0) = 556*ma.SR/origSR : int;
    allpasstuningL(1) = 441*ma.SR/origSR : int;
    allpasstuningL(2) = 341*ma.SR/origSR : int;
    allpasstuningL(3) = 225*ma.SR/origSR : int;
    // Lowpass Feedback Combfiler:
    // https://ccrma.stanford.edu/~jos/pasp/Lowpass_Feedback_Comb_Filter.html
    lbcf(dt, fb, damp) = (+:@(dt)) ~ (*(1-damp) : (+ ~ *(damp)) : *(fb));
};
stereo_freeverb(fb1, fb2, damp, spread) =  + <: mono_freeverb(fb1, fb2, damp,0), mono_freeverb(fb1, fb2, damp, spread);


//--------------------------------`fdnrev0`---------------------------------
// Pure Feedback Delay Network Reverberator (generalized for easy scaling).
//
// #### Usage
//
// ```
// <1,2,4,...,N signals> <:
// fdnrev0(MAXDELAY,delays,BBSO,freqs,durs,loopgainmax,nonl) :>
// <1,2,4,...,N signals>
// ```
//
// Where:
//
// * `N`: 2, 4, 8, ...  (power of 2)
// * `MAXDELAY`: power of 2 at least as large as longest delay-line length
// * `delays`: N delay lines, N a power of 2, lengths perferably coprime
// * `BBSO`: odd positive integer = order of bandsplit desired at freqs
// * `freqs`: NB-1 crossover frequencies separating desired frequency bands
// * `durs`: NB decay times (t60) desired for the various bands
// * `loopgainmax`: scalar gain between 0 and 1 used to "squelch" the reverb
// * `nonl`: nonlinearity (0 to 0.999..., 0 being linear)
//
// #### Reference
//
// <https://ccrma.stanford.edu/~jos/pasp/FDN_Reverberation.html>
//------------------------------------------------------------
// TODO: author JOS, revised by RM
fdnrev0(MAXDELAY, delays, BBSO, freqs, durs, loopgainmax, nonl)
  = (si.bus(2*N) :> si.bus(N) : delaylines(N)) ~
    (delayfilters(N,freqs,durs) : feedbackmatrix(N))
with {
  N = ba.count(delays);
  NB = ba.count(durs);
//assert(count(freqs)+1==NB);
  delayval(i) = ba.take(i+1,delays);
  dlmax(i) = MAXDELAY; // must hardwire this from argument for now
//dlmax(i) = 2^max(1,nextpow2(delayval(i))) // try when slider min/max is known
//           with { nextpow2(x) = ceil(log(x)/log(2.0)); };
// -1 is for feedback delay:
  delaylines(N) = par(i,N,(de.delay(dlmax(i),(delayval(i)-1))));
  delayfilters(N,freqs,durs) = par(i,N,filter(i,freqs,durs));
  feedbackmatrix(N) = bhadamard(N);
  vbutterfly(n) = si.bus(n) <: (si.bus(n):>bus(n/2)) , ((si.bus(n/2),(si.bus(n/2):par(i,n/2,*(-1)))) :> si.bus(n/2));
  bhadamard(2) = si.bus(2) <: +,-;
  bhadamard(n) = si.bus(n) <: (si.bus(n):>si.bus(n/2)) , ((si.bus(n/2),(si.bus(n/2):par(i,n/2,*(-1)))) :> si.bus(n/2))
                 : (bhadamard(n/2) , bhadamard(n/2));

  // Experimental nonlinearities:
  // nonlinallpass = apnl(nonl,-nonl);
  // s = nonl*PI;
  // nonlinallpass(x) = allpassnn(3,(s*x,s*x*x,s*x*x*x)); // filter.lib
     nonlinallpass = _; // disabled by default (rather expensive)

  filter(i,freqs,durs) = fi.filterbank(BBSO,freqs) : par(j,NB,*(g(j,i)))
                         :> *(loopgainmax) / sqrt(N) : nonlinallpass
  with {
    dur(j) = ba.take(j+1,durs);
    n60(j) = dur(j)*ma.SR; // decay time in samples
    g(j,i) = exp(-3.0*log(10.0)*delayval(i)/n60(j));
        // ~ 1.0 - 6.91*delayval(i)/(SR*dur(j)); // valid for large dur(j)
  };
};


// ----------`prime_power_delays`-----------
// Prime Power Delay Line Lengths.
//
// #### Usage
//
// ```
// bus(N) : prime_power_delays(N,pathmin,pathmax) : bus(N);
// ```
//
// Where:
//
// * `N`: positive integer up to 16 (for higher powers of 2, extend 'primes' array below.)
// * `pathmin`: minimum acoustic ray length in the reverberator (in meters)
// * `pathmax`: maximum acoustic ray length (meters) - think "room size"
//
// #### Reference
//
// <https://ccrma.stanford.edu/~jos/pasp/Prime_Power_Delay_Line.html>
//------------------------------------------------------------
// TODO: author JOS, revised by RM
// TODO: may be this should be moved to delay.lib?
prime_power_delays(N,pathmin,pathmax) = par(i,N,delayvals(i)) with {
  Np = 16;
  primes = 2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53;
  prime(n) = primes : ba.selector(n,Np); // math.lib

  // Prime Power Bounds [matlab: floor(log(maxdel)./log(primes(53)))]
  maxdel=8192; // more than 63 meters at 44100 samples/sec & 343 m/s
  ppbs = 13,8,5,4, 3,3,3,3, 2,2,2,2, 2,2,2,2; // 8192 is enough for all
  ppb(i) = ba.take(i+1,ppbs);

  // Approximate desired delay-line lengths using powers of distinct primes:
  c = 343; // soundspeed in m/s at 20 degrees C for dry air
  dmin = ma.SR*pathmin/c;
  dmax = ma.SR*pathmax/c;
  dl(i) = dmin * (dmax/dmin)^(i/float(N-1)); // desired delay in samples
  ppwr(i) = floor(0.5+log(dl(i))/log(prime(i))); // best prime power
  delayvals(i) = prime(i)^ppwr(i); // each delay a power of a distinct prime
};


//-------------------------------`zita_rev_fdn`-------------------------------
// Internal 8x8 late-reverberation FDN used in the FOSS Linux reverb zita-rev1
// by Fons Adriaensen <fons@linuxaudio.org>.  This is an FDN reverb with
// allpass comb filters in each feedback delay in addition to the
// damping filters.
//
// #### Usage
//
// ```
// bus(8) : zita_rev_fdn(f1,f2,t60dc,t60m,fsmax) : bus(8)
// ```
//
// Where:
//
// * `f1`: crossover frequency (Hz) separating dc and midrange frequencies
// * `f2`: frequency (Hz) above f1 where T60 = t60m/2 (see below)
// * `t60dc`: desired decay time (t60) at frequency 0 (sec)
// * `t60m`: desired decay time (t60) at midrange frequencies (sec)
// * `fsmax`: maximum sampling rate to be used (Hz)
//
// #### Reference
//
// * <http://www.kokkinizita.net/linuxaudio/zita-rev1-doc/quickguide.html>
// * <https://ccrma.stanford.edu/~jos/pasp/Zita_Rev1.html>
//------------------------------------------------------------
// TODO: author JOS, revised by RM
zita_rev_fdn(f1,f2,t60dc,t60m,fsmax) =
  ((si.bus(2*N) :> allpass_combs(N) : feedbackmatrix(N)) ~
   (delayfilters(N,freqs,durs) : fbdelaylines(N)))
with {
  N = 8;

  // Delay-line lengths in seconds:
  apdelays = (0.020346, 0.024421, 0.031604, 0.027333, 0.022904,
              0.029291, 0.013458, 0.019123); // feedforward delays in seconds
  tdelays = ( 0.153129, 0.210389, 0.127837, 0.256891, 0.174713,
              0.192303, 0.125000, 0.219991); // total delays in seconds
  tdelay(i) = floor(0.5 + ma.SR*ba.take(i+1,tdelays)); // samples
  apdelay(i) = floor(0.5 + ma.SR*ba.take(i+1,apdelays));
  fbdelay(i) = tdelay(i) - apdelay(i);
  // NOTE: Since SR is not bounded at compile time, we can't use it to
  // allocate delay lines; hence, the fsmax parameter:
  tdelaymaxfs(i) = floor(0.5 + fsmax*ba.take(i+1,tdelays));
  apdelaymaxfs(i) = floor(0.5 + fsmax*ba.take(i+1,apdelays));
  fbdelaymaxfs(i) = tdelaymaxfs(i) - apdelaymaxfs(i);
  nextpow2(x) = ceil(log(x)/log(2.0));
  maxapdelay(i) = int(2.0^max(1.0,nextpow2(apdelaymaxfs(i))));
  maxfbdelay(i) = int(2.0^max(1.0,nextpow2(fbdelaymaxfs(i))));

  apcoeff(i) = select2(i&1,0.6,-0.6);  // allpass comb-filter coefficient
  allpass_combs(N) =
    par(i,N,(fi.allpass_comb(maxapdelay(i),apdelay(i),apcoeff(i)))); // filter.lib
  fbdelaylines(N) = par(i,N,(de.delay(maxfbdelay(i),(fbdelay(i)))));
  freqs = (f1,f2); durs = (t60dc,t60m);
  delayfilters(N,freqs,durs) = par(i,N,filter(i,freqs,durs));
  feedbackmatrix(N) = si.hadamard(N);

  staynormal = 10.0^(-20); // let signals decay well below LSB, but not to zero

  special_lowpass(g,f) = si.smooth(p) with {
    // unity-dc-gain lowpass needs gain g at frequency f => quadratic formula:
    p = mbo2 - sqrt(max(0,mbo2*mbo2 - 1.0)); // other solution is unstable
    mbo2 = (1.0 - gs*c)/(1.0 - gs); // NOTE: must ensure |g|<1 (t60m finite)
    gs = g*g;
    c = cos(2.0*ma.PI*f/float(ma.SR));
  };

  filter(i,freqs,durs) = lowshelf_lowpass(i)/sqrt(float(N))+staynormal
  with {
    lowshelf_lowpass(i) = gM*low_shelf1_l(g0/gM,f(1)):special_lowpass(gM,f(2));
    low_shelf1_l(G0,fx,x) = x + (G0-1)*fi.lowpass(1,fx,x); // filter.lib
    g0 = g(0,i);
    gM = g(1,i);
    f(k) = ba.take(k,freqs);
    dur(j) = ba.take(j+1,durs);
    n60(j) = dur(j)*ma.SR; // decay time in samples
    g(j,i) = exp(-3.0*log(10.0)*tdelay(i)/n60(j));
  };
};

// Stereo input delay used by zita_rev1 in both stereo and ambisonics mode:
zita_in_delay(rdel) = zita_delay_mono(rdel), zita_delay_mono(rdel) with {
  zita_delay_mono(rdel) = de.delay(8192,ma.SR*rdel*0.001) * 0.3;
};

// Stereo input mapping used by zita_rev1 in both stereo and ambisonics mode:
zita_distrib2(N) = _,_ <: fanflip(N) with {
   fanflip(4) = _,_,*(-1),*(-1);
   fanflip(N) = fanflip(N/2),fanflip(N/2);
};


//----------------------------`zita_rev1_stereo`---------------------------
// Extend `zita_rev_fdn` to include `zita_rev1` input/output mapping in stereo mode.
//
// #### Usage
//
// ```
// _,_ : zita_rev1_stereo(rdel,f1,f2,t60dc,t60m,fsmax) : _,_
// ```
//
// Where:
//
// `rdel`  = delay (in ms) before reverberation begins (e.g., 0 to ~100 ms)
// (remaining args and refs as for `zita_rev_fdn` above)
//------------------------------------------------------------
// TODO: author JOS, revised by RM
zita_rev1_stereo(rdel,f1,f2,t60dc,t60m,fsmax) =
   zita_in_delay(rdel)
 : zita_distrib2(N)
 : zita_rev_fdn(f1,f2,t60dc,t60m,fsmax)
 : output2(N)
with {
 N = 8;
 output2(N) = outmix(N) : *(t1),*(t1);
 t1 = 0.37; // zita-rev1 linearly ramps from 0 to t1 over one buffer
 outmix(4) = !,si.butterfly(2),!; // probably the result of some experimenting!
 outmix(N) = outmix(N/2),par(i,N/2,!);
};


//-----------------------------`zita_rev1_ambi`---------------------------
// Extend zita_rev_fdn to include zita_rev1 input/output mapping in
// "ambisonics mode", as provided in the Linux C++ version.
//
// #### Usage
//
// ```
// _,_ : zita_rev1_ambi(rgxyz,rdel,f1,f2,t60dc,t60m,fsmax) : _,_,_,_
// ```
//
// Where:
//
// `rgxyz` = relative gain of lanes 1,4,2 to lane 0 in output (e.g., -9 to 9)
//   (remaining args and references as for zita_rev1_stereo above)
//------------------------------------------------------------
// TODO: author JOS, revised by RM
zita_rev1_ambi(rgxyz,rdel,f1,f2,t60dc,t60m,fsmax) =
   zita_in_delay(rdel)
 : zita_distrib2(N)
 : zita_rev_fdn(f1,f2,t60dc,t60m,fsmax)
 : output4(N) // ambisonics mode
with {
  N=8;
  output4(N) = select4 : *(t0),*(t1),*(t1),*(t1);
  select4 = _,_,_,!,_,!,!,! : _,_,cross with { cross(x,y) = y,x; };
  t0 = 1.0/sqrt(2.0);
  t1 = t0 * 10.0^(0.05 * rgxyz);
};


// TODO: the following should be in pm.lib
//----------------------------------`mesh_square`------------------------------
// Square Rectangular Digital Waveguide Mesh.
//
// #### Usage
//
// ```
// bus(4*N) : mesh_square(N) : bus(4*N);
// ```
//
// Where:
//
// * `N`: number of nodes along each edge - a power of two (1,2,4,8,...)
//
// #### Reference
//
// <https://ccrma.stanford.edu/~jos/pasp/Digital_Waveguide_Mesh.html>
//
// #### Signal Order In and Out
//
// The mesh is constructed recursively using 2x2 embeddings.  Thus,
// the top level of `mesh_square(M)` is a block 2x2 mesh, where each
// block is a `mesh(M/2)`.  Let these blocks be numbered 1,2,3,4 in the
// geometry NW,NE,SW,SE, i.e., as
//         1 2
//         3 4
// Each block has four vector inputs and four vector outputs, where the
// length of each vector is `M/2`.  Label the input vectors as Ni,Ei,Wi,Si,
// i.e., as the inputs from the North, East South, and West,
// and similarly for the outputs.  Then, for example, the upper
// left input block of M/2 signals is labeled 1Ni.  Most of the
// connections are internal, such as 1Eo -> 2Wi.  The `8*(M/2)` input
// signals are grouped in the order
//        1Ni 2Ni
//        3Si 4Si
//        1Wi 3Wi
//        2Ei 4Ei
// and the output signals are
//        1No 1Wo
//        2No 2Eo
//        3So 3Wo
//        4So 4Eo
// or
//
// In: 1No 1Wo 2No 2Eo 3So 3Wo 4So 4Eo
//
// Out: 1Ni 2Ni 3Si 4Si 1Wi 3Wi 2Ei 4Ei
//
// Thus, the inputs are grouped by direction N,S,W,E, while the
// outputs are grouped by block number 1,2,3,4, which can also be
// interpreted as directions NW, NE, SW, SE.  A simple program
// illustrating these orderings is `process = mesh_square(2);`.
//
// #### Example
//
// Reflectively terminated mesh impulsed at one corner:
//
// ```
// mesh_square_test(N,x) = mesh_square(N)~(busi(4*N,x)) // input to corner
// with { busi(N,x) = bus(N) : par(i,N,*(-1)) : par(i,N-1,_), +(x); };
// process = 1-1' : mesh_square_test(4); // all modes excited forever
// ```
//
// In this simple example, the mesh edges are connected as follows:
//
// 1No -> 1Ni, 1Wo -> 2Ni, 2No -> 3Si, 2Eo -> 4Si,
//
// 3So -> 1Wi, 3Wo -> 3Wi, 4So -> 2Ei, 4Eo -> 4Ei
//
// A routing matrix can be used to obtain other connection geometries.
//------------------------------------------------------------
// TODO: author JOS, revised by RM
// four-port scattering junction:
mesh_square(1) =
          si.bus(4) <: par(i,4,*(-1)), (si.bus(4) :> (*(.5)) <: si.bus(4)) :> si.bus(4);

// rectangular NxN square waveguide mesh:
mesh_square(N) = si.bus(4*N) : (route_inputs(N/2) : par(i,4,mesh_square(N/2)))
          ~(prune_feedback(N/2))
          : prune_outputs(N/2) : route_outputs(N/2) : si.bus(4*N)
with {
  // select block i of N, block size = M:
  s(i,N,M) = par(j, M*N, Sv(i, j))
     with { Sv(i,i) = si.bus(N); Sv(i,j) = si.block(N); };

  // prune mesh outputs down to the signals which make it out:
  prune_outputs(N)
    = si.bus(16*N) :
      si.block(N), si.bus(N),   si.block(N), si.bus(N),
      si.block(N), si.bus(N),   si.bus(N),   si.block(N),
      si.bus(N),   si.block(N), si.block(N), si.bus(N),
      si.bus(N),   si.block(N), si.bus(N),   si.block(N)
      : si.bus(8*N);

  // collect mesh outputs into standard order (N,W,E,S):
  route_outputs(N)
    = si.bus(8*N)
      <: s(4,N,8),s(5,N,8), s(0,N,8),s(2,N,8),
         s(3,N,8),s(7,N,8), s(1,N,8),s(6,N,8)
      : si.bus(8*N);

  // collect signals used as feedback:
  prune_feedback(N) = si.bus(16*N) :
      si.bus(N),   si.block(N), si.bus(N),   si.block(N),
      si.bus(N),   si.block(N), si.block(N), si.bus(N),
      si.block(N), si.bus(N),   si.bus(N),   si.block(N),
      si.block(N), si.bus(N),   si.block(N), si.bus(N) :
      si.bus(8*N);

  // route mesh inputs (feedback, external inputs):
  route_inputs(N) = si.bus(8*N), si.bus(8*N)
  <:s(8,N,16),s(4,N,16), s(12,N,16),s(3,N,16),
    s(9,N,16),s(6,N,16), s(1,N,16),s(14,N,16),
    s(0,N,16),s(10,N,16), s(13,N,16),s(7,N,16),
    s(2,N,16),s(11,N,16), s(5,N,16),s(15,N,16)
    : si.bus(16*N);
};


//////////////////////////////////Deprecated Functions////////////////////////////////////
// This section implements functions that used to be in music.lib but that are now
// considered as "deprecated".
//////////////////////////////////////////////////////////////////////////////////////////

echo1s  = vgroup("echo  1000", +~(de.delay(65536,   int(hslider("millisecond", 0, 0,	1000, 0.10)*ba.millisec)-1) * (hslider("feedback", 0, 0,  100, 0.1)/100.0)));
echo2s  = vgroup("echo  2000", +~(de.delay(131072,  int(hslider("millisecond", 0, 0,	2000, 0.25)*ba.millisec)-1) * (hslider("feedback", 0, 0,  100, 0.1)/100.0)));
echo5s  = vgroup("echo  5000", +~(de.delay(262144,  int(hslider("millisecond", 0, 0,	5000, 0.50)*ba.millisec)-1) * (hslider("feedback", 0, 0,  100, 0.1)/100.0)));
echo10s = vgroup("echo 10000", +~(de.delay(524288,  int(hslider("millisecond", 0, 0,  10000, 1.00)*ba.millisec)-1) * (hslider("feedback", 0, 0,  100, 0.1)/100.0)));
echo21s = vgroup("echo 21000", +~(de.delay(1048576, int(hslider("millisecond", 0, 0,  21000, 1.00)*ba.millisec)-1) * (hslider("feedback", 0, 0,  100, 0.1)/100.0)));
echo43s = vgroup("echo 43000", +~(de.delay(2097152, int(hslider("millisecond", 0, 0,  43000, 1.00)*ba.millisec)-1) * (hslider("feedback", 0, 0,  100, 0.1)/100.0)));



