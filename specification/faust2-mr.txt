===============================================================================
SPECIFICATION OF MULTI-RATE COMPILATIONS RULES
===============================================================================

Types definition
T = int | float | [n]T

A : symbolic name

E : signal expression
E = InX | P(E1,..) | Num(x) | Vectorize(n,E) | Serialize(E) | E1#E2 | E1[E2] | DL(E1)@E2 | Proj(n, g = (E0,E1,...))

V : compilation value
V = int | float | Load(A, I) | P(V1,..)

S : compilation statement
S : T A | Store(A, I, V) | Loop(i, n) { S* } | SubLoop(i, n) { S* }

I : access indexes
I : int | Var(string) | Binop(i1, i2)      (with Binop : +,-,*,/)

A compilation value V has a type given with type(V) = T

cast(T,A) : cast the vector with the type T

In each compilation rule:

- the "+" symbol means "adding a statement in the current loop"
- the ">" symbol means "returning a value"

===============================================================================
COMPLEX VERSION WITH DESTINATION AND INDEX
===============================================================================

CTOP[E0, E1...]         = compile each output signal
CV[O, E]                = compile Vector, fill vector O with count*rate samples of signal E, no value
CA[O, Os, E, Is]   		= compile Assignment, store in O at index Os , the value of signal E at index Is, no value
CS[E, Is]            	= compile Sample, compute the value of signal E at index Is, returns a value
CD[DL(E)]               = create a delay line, write signal, returns the delay line

VS = vector size
count = implicit parameter indicating how many samples at rate 1 we will compute
count <= VS

-------------------------------------------------------------------------------
CTOP[E0, E1, E2, ...] = compile each output signal
-------------------------------------------------------------------------------
   	ri = rate(Ei)
   	Ti = int | float = type(Ei)
	[ri*VS]Ti = type(OUTi)

+	CV[OUT0, E0]
+	CV[OUT1, E1]
+	....

-------------------------------------------------------------------------------
CV[O, E] = compile vector, fill vector O with count*rate samples of signal E
-------------------------------------------------------------------------------
   	r = rate(E)
   	T = type(E)
	[r*VS]T = type(O)
	i = fresh index

+	Loop(i, r*count) {
+		CA[O, [i], E, [i]]
+	}


===============================================================================
Num(x) : number (int or float) of value 'x'
===============================================================================

-------------------------------------------------------------------------------
CA[O, Os, Num(x), Is] : A x [I] x E x [I] ==> void
-------------------------------------------------------------------------------
+	Store(O, CS[Num(x), Is], Os)

-------------------------------------------------------------------------------
CS[Num(x), Is] : E x [I] x [I] ==> V
-------------------------------------------------------------------------------
>	x (of type int | float)


===============================================================================
InX : input x
===============================================================================

-------------------------------------------------------------------------------
CA[O, Os, InX, Is] : A x [I] x E x [I] ==> void
-------------------------------------------------------------------------------
+	Store(O, Os, CS[InX, Is])

-------------------------------------------------------------------------------
CS[InX, Is]: E x [I] x [I] ==> V
-------------------------------------------------------------------------------
>	Load(InX, Is) (of type int | float)


===============================================================================
P(E1,E2,..) : primitive operation on signals
===============================================================================
	r = rate(P(E1,E2,..))
	T = type(P(E1,E2,..))

-------------------------------------------------------------------------------
CA[O, Os, P(E1,E2,..), Is] : A x [I] x E x [I] ==> void
-------------------------------------------------------------------------------
+	Store(O, Os, CS[P(E1,E2,..), Is])

-------------------------------------------------------------------------------
CS[P(E1,..), Is] : E x [I] x [I] ==> V
-------------------------------------------------------------------------------
	j is a fresh loop index

if not shared (P(E1,E2,..)) : we can inline the expression

>	P(CS[E1,Is],CS[E2,Is],...)

if shared (P(E1,E2,..)) : we need an intermediate buffer W to store
+ 	T 	W[r*VS]
+	Loop(j, r*count) {
+		Store(W, [j], P(CS[E1,[j]],...))
+	}

>	Load(W, Is)  (of type T)


===============================================================================
Vectorize(n,E) : create a signal of vectors of size n and rate r/n
===============================================================================
       n*m = rate(E)
   	     T = type(E)

 	     m = rate(Vectorize(n,E))
      T[n] = type(Vectorize(n,E))

-------------------------------------------------------------------------------
CA[O, Os, Vectorize(n,E), Is] : A x [I] x E x [I] ==> void
-------------------------------------------------------------------------------
	k is a fresh loop index

if not shared (Vectorize(n,E)) :

+	SubLoop(k, n) {
+		CA[O, [Os, k], E, Is*n+k]
+ 	}

if shared (Vectorize(n,E)) :

+	Store(O, Os, CS[Vectorize(n,E),Is])


-------------------------------------------------------------------------------
CS[Vectorize(n,E),Is] : E x [I] x [I] ==> V
-------------------------------------------------------------------------------
	j and k are fresh loop indexes

+	T[n] W[m*VS]
+	Loop(j, m*VS) {
+		SubLoop(k, n) {
+			CA[W, [j, k], E, [j*n+k]]
+		}
+	}

>	Load(W, Is) (of type [n]T)

===============================================================================
Serialize(E) : Serialize a signal of vectors
===============================================================================
     m = rate(E)
  T[n] = type(E)

   n.m = rate(Serialize(E))
     T = type(Serialize(E))

-------------------------------------------------------------------------------
CA[O, Os, Serialize(E), Is] : A x [I] x E x [I] ==> void
-------------------------------------------------------------------------------

if not shared (Serialize(E)) :

+   if (Is%n == 0) {
+       CA[cast(T[n],O), Os, E, Is/n]  (here we "divide" Is by n..)
+   }

if shared (Serialize(E)) :

+   Store(O, Os, CS[Serialize(E),Is])

-------------------------------------------------------------------------------
CS[Serialize(E), Is] : E x [I] x [I] ==> V
-------------------------------------------------------------------------------
    j and k are fresh loop indexes

+	T W[n*m*VS]
+	Loop(j, m*VS) {
+		SubLoop(k, n) {
+			CA[W, [j*n+k], E, [j,k]]
+		}
+	}

> Load(W, Is) (of type T)


===============================================================================
E1#E2 : concatenate two signals of vectors
===============================================================================
       r = rate(E1#E2) = rate(E1) = rate(E2)
    T[n] = type(E1)
    T[m] = type(E2)
  T[n+m] = type(E1#E2)

-------------------------------------------------------------------------------
CA[O, Os, E1#E2, Is] : A x [I] x E x [I] ==> void
-------------------------------------------------------------------------------

if not shared (E1#E2) :

+	CA[O, Os, E1, Is]
+	CA[O, Os+n, E2, Is]  (here we "move" Os by n..)

if shared (E1#E2) :

+	Store(O, Os, CS[E1#E2, Is])

-------------------------------------------------------------------------------
CS[E1#E2, Is] : E x [I] x [I] ==> V
-------------------------------------------------------------------------------
	j and k are fresh loop indexes

+	T[n+m] W[r*VS]
+	Loop(j, r*VS) {
+		SubLoop(k, n) {
+           CA[W, [j,k], E1, [j,k]]
+       }
+		SubLoop(k, n) {
+           CA[W, [j,n+k], E2, [j,k]]
+       }
+   }

>   Load(W, Is)  (of type [n+m]T)


===============================================================================
E1[E2] : takes value of a signal at a given index
===============================================================================
       r = rate(E1[E2]) = rate(E1) = rate(E2)
    T[n] = type(E1)
     int = type(E2) in (0, n-1)
       T = type(E1[E2])

-------------------------------------------------------------------------------
CA[O, Os, E1[E2], Is] : A x [I] x E x [I] ==> void
-------------------------------------------------------------------------------

+   Store(O, Os, CS[E1[E2],Is])

-------------------------------------------------------------------------------
CS[E1[E2], Is] : E x [I] x [I] ==> V
-------------------------------------------------------------------------------

>   CS[E1,Is][CS[E2,Is]]  (of type T)


===============================================================================
Proj(n, g = (E0, E1, ...)) : projection of a recursive group
===============================================================================
       r = rate(E0) = rate(E1) = ...
      T0 = type(E0), T1 = type(E1), ...
      m0 = maxdelay(E0), m1 = maxdelay(E1), ...

-------------------------------------------------------------------------------
CA[O, Os, Proj(n, g = (E0, E1, ...)), Is] : A x [I] x E x [I] ==> void
-------------------------------------------------------------------------------

+   Store(O, Os, CS[Proj(n, g = (E0, E1, ...)),Is])

-------------------------------------------------------------------------------
CS[Proj(n, g = (E0, E1, ...)), Is] : E x [I] x [I] ==> V
-------------------------------------------------------------------------------
       r = rate(E0) = rate(E1) = ...
      T0 = type(E0), T1 = type(E1), ...
      m0 = maxdelay(E0), m1 = maxdelay(E1), ...

+	T0 W0[r*VS + m0]
+	T1 W1[r*VS + m1]
+   ....
+	Loop(j, m*VS) {
+       CA[W0, [j], E0, [j]]
+       CA[W1, [j], E1, [j]]
+       ....
+	}

>   Load(Wn, Is) (of type Tn)


===============================================================================
DL(E1)@E2 : read in a delay line
===============================================================================
       r = rate(DL(E1)@E2) = rate(DL(E1)) = rate(E1) = rate(E2)
       T = type(DL(E1)) = type(E1)
     int = type(E2)
       d = maxdelay(DL(E1))

-------------------------------------------------------------------------------
CA[O, Os, DL(E1)@E2, Is] : A x [I] x E x [I] ==> void
-------------------------------------------------------------------------------

+   Store(O, Os, CS[DL(E1)@E2, Is])

-------------------------------------------------------------------------------
CS[DL(E1)@E2, Is] : E x [I] x [I] ==> V
-------------------------------------------------------------------------------

if d is small :
+   W = CD[DL(E1)]

>   Load(W, [Is-CS[E2,Is]])  (of type T)

TODO : when d is not small


===============================================================================
CD[DL(E)] : create a delay line and write signal
===============================================================================
       r = rate(DL(E)) = rate(E)
       T = type(DL(E)) = type(E)
       d = maxdelay(DL(E))

-------------------------------------------------------------------------------
CD[DL(E)] : E ==> A
-------------------------------------------------------------------------------

if d is small :

+	T M[d]
+	T RM[r*VS + d]
+	T* R = RM[d]
+	Loop(j, d) {
+       Store(RM, [j], Load(M, [j]))
+	}
+	Loop(j, r*VS) {
+       CA[RM, [d+j], E, [j]]
+	}
+	Loop(j, d) {
+       Store(M, [j], Load(RM, [r*VS+j]))
+	}

>   R  (of type [r*VS]T)

TODO : when d is not small
