===============================================================================
SPECIFICATION OF MULTI-RATE COMPILATIONS RULES
===============================================================================

Types definition
T = int | float | T[n]

E : signal expression
E = INx | P(E1,..) | NUM(x) | vectorize(n,E) | serialize(E) | E1#E2 | E1[E2] | DL(E1)@E2 | PROJ(n, g = (E0, E1, ...))

V : compilation value
V = int | float | V[n] | P(V1,..)

S : compilation statement
S : A = V | Loop(i, n) { S* } | SubLoop(i, n) { S* }

I : access indexes
I : int | Binop(i1, i2)  with Binop : +,-,*,/

A compilation value V has a type given with type(V) = T

addr(V)     : takes the address of some value of type T
cast(T,V)   : cast the value with the type T

In each compilation rule:

- the "+" symbol means "adding a statement in the current loop"
- the ">" symbol means "returning a value"

===============================================================================
COMPLEX VERSION WITH DESTINATION AND INDEX
===============================================================================

CTOP[E0, E1...] = compile each output signal
CV[A, E]        = compile Vector, fill vector A with count*rate samples of signal E, no value
CA[A, E, I]     = compile Assignment, store in A the value of signal E at index I, no value
CS[E, I]        = compile Sample, compute the value of signal E at index I, returns a value
CD[DL(E)]       = create a delay line, write signal, returns the delay line

VS = vector size
count = implicit parameter indicating how many samples at rate 1 we will compute
count <= VS

-------------------------------------------------------------------------------
CTOP[E0, E1, E2, ...] = compile each output signal
-------------------------------------------------------------------------------
   	ri = rate(Ei)
   	Ti = int | float = type(Ei)
	Ti[ri*VS] = type(OUTi)

+	CV[OUT0, E0]
+	CV[OUT1, E1]
+	....

-------------------------------------------------------------------------------
CV[A, E] = compile vector, fill vector A with count*rate samples of signal E
-------------------------------------------------------------------------------
   	r = rate(E)
   	T = type(E)
	T[r*VS] = type(A)
	i = fresh int variable

+	Loop(i, r*count) {
+		CA[addr(A[i]), E, i]
+	}


===============================================================================
NUM(x) : number (int or float) of value 'x'
===============================================================================

-------------------------------------------------------------------------------
CA[A, NUM(x), I] : &T x E x I ==> void
-------------------------------------------------------------------------------
+	A = CS[NUM(x), I]

-------------------------------------------------------------------------------
CS[NUM(x), I] : E x I ==> V
-------------------------------------------------------------------------------
>	x (of type int | float)


===============================================================================
INx : input x
===============================================================================

-------------------------------------------------------------------------------
CA[A, INx, I] : &T x E x I ==> void
-------------------------------------------------------------------------------
+	A = CS[INx, I]

-------------------------------------------------------------------------------
CS[INx, I]: E x int ==> V
-------------------------------------------------------------------------------
>	INx[I] (of type int | float)


===============================================================================
P(E1,E2,..) : primitive operation on signals
===============================================================================
	r = rate(P(E1,E2,..))
	T = type(P(E1,E2,..))

-------------------------------------------------------------------------------
CA[A, P(E1,E2,..), I] : &T x E x I ==> void
-------------------------------------------------------------------------------
+	A = CS[P(E1,E2,..), I]

-------------------------------------------------------------------------------
CS[P(E1,..), I] : E x I ==> V
-------------------------------------------------------------------------------
	j is a fresh loop index

if not shared (P(E1,E2,..)) : we can inline the expression

>	P(CS[E1,I],CS[E2,I],...)

if shared (P(E1,E2,..)) : we need an intermediated buffer W to store
+ 	T 	W[r*VS]
+	Loop(j, r*count) {
+		W[j] = P(CS[E1,j],...)
+	}

>	W[I]  (of type T)


===============================================================================
vectorize(n,E) : create a signal of vectors of size n and rate r/n
===============================================================================
       n*m = rate(E)
   	     T = type(E)

 	     m = rate(vectorize(n,E))
      T[n] = type(vectorize(n,E))

-------------------------------------------------------------------------------
CA[A, vectorize(n,E), I] : &T x E x I ==> void
-------------------------------------------------------------------------------
	k is a fresh loop index

if not shared (vectorize(n,E)) :

+	SubLoop(k, n) {
+		CA[addr(A[k]), E, I*n+k]
+ 	}

if shared (vectorize(n,E)) :

+	A = CS[vectorize(n,E), I]


-------------------------------------------------------------------------------
CS[vectorize(n,E), I] : E x I ==> V
-------------------------------------------------------------------------------
	j and k are fresh loop indexes

+	T[n] W[m*VS]
+	Loop(j, m*VS) {
+		SubLoop(k, n) {
+			CA[addr(W[j][k]), E, j*n+k]
+		}
+	}

>	W[I] (of type T[n])

===============================================================================
serialize(E) : serialize a signal of vectors
===============================================================================
     m = rate(E)
  T[n] = type(E)

   n.m = rate(serialize(E))
     T = type(serialize(E))

-------------------------------------------------------------------------------
CA[A, serialize(E), I] : &T x E x I ==> void
-------------------------------------------------------------------------------

if not shared (serialize(E)) :

+   if (I%n == 0) {
+       CA[cast(T[n],A), E, I/n]
+   }

if shared (serialize(E)) :

+   A = CS[serialize(E), I]

-------------------------------------------------------------------------------
CS[serialize(E), I] : E x I ==> V
-------------------------------------------------------------------------------
    j and k are fresh loop indexes

+	T W[n*m*VS]
+	Loop(j, m*VS) {
+		SubLoop(k, n) {
+			W[j*n+k] = CS[E,j][k]
+		}
+	}

> W[I] (of type T)

===============================================================================
E1#E2 : concatenate two signals of vectors
===============================================================================
       r = rate(E1#E2) = rate(E1) = rate(E2)
    T[n] = type(E1)
    T[m] = type(E2)
  T[n+m] = type(E1#E2)

-------------------------------------------------------------------------------
CA[A, E1#E2, I] : &T x E x I ==> void
-------------------------------------------------------------------------------

if not shared (E1#E2) :

+	CA[A, E1, I]
+	CA[A+n, E2, I]

if shared (E1#E2) :

+	A = CS[E1#E2, I]

-------------------------------------------------------------------------------
CS[E1#E2, I] : E x I ==> V
-------------------------------------------------------------------------------
	j and k are fresh loop indexes

+	T[n+m] W[r*VS]
+	Loop(j, r*VS) {
+		SubLoop(k, n) {
+           W[j][k] = CS[E1,j][k]
+       }
+		SubLoop(k, n) {
+           W[j][n+k] = CS[E2,j][k]
+       }
+   }

>   W[I]  (of type T[n+m])


===============================================================================
E1[E2] : takes value of a signal at a given index
===============================================================================
       r = rate(E1[E2]) = rate(E1) = rate(E2)
    T[n] = type(E1)
     int = type(E2) in (0, n-1)
       T = type(E1[E2])

-------------------------------------------------------------------------------
CA[A, E1[E2], I] : &T x E x I ==> void
-------------------------------------------------------------------------------

+   A = CS[E1[E2], I]

-------------------------------------------------------------------------------
CS[E1[E2], I] : E x I ==> V
-------------------------------------------------------------------------------

>   CS[E1,I][CS[E2,I]]  (of type T)


===============================================================================
PROJ(n, g = (E0, E1, ...)) : projection of a recursive group
===============================================================================
       r = rate(E0) = rate(E1) = ...
      T0 = type(E0), T1 = type(E1), ...
      m0 = maxdelay(E0), m1 = maxdelay(E1), ...

-------------------------------------------------------------------------------
CA[A, PROJ(n, g = (E0, E1, ...)), I] : &T x E x I ==> void
-------------------------------------------------------------------------------

+   A = CS[PROJ(n, g = (E0, E1, ...)), I]

-------------------------------------------------------------------------------
CS[PROJ(n, g = (E0, E1, ...)), I] : E x I ==> V
-------------------------------------------------------------------------------
       r = rate(E0) = rate(E1) = ...
      T0 = type(E0), T1 = type(E1), ...
      m0 = maxdelay(E0), m1 = maxdelay(E1), ...

+	T0 W0[r*VS + m0]
+	T1 W1[r*VS + m1]
+   ....
+	Loop(j, m*VS) {
+       CS[addr(W0[i]), E0, i]
+       CS[addr(W1[i]), E1, i]
+       ....
+	}

>   Wn[I] (of type Tn)


===============================================================================
DL(E1)@E2 : read in a delay line
===============================================================================
       r = rate(DL(E1)@E2) = rate(DL(E1)) = rate(E1) = rate(E2)
       T = type(DL(E1)) = type(E1)
     int = type(E2)
       d = maxdelay(DL(E1))

-------------------------------------------------------------------------------
CA[A, DL(E1)@E2, I] : &T x E x I ==> void
-------------------------------------------------------------------------------

+   A = CS[DL(E1)@E2, I]

-------------------------------------------------------------------------------
CS[DL(E1)@E2, I] : E x I ==> V
-------------------------------------------------------------------------------

if d is small :
+ 	W = CD[DL(E1)]

>   W[I-CS[E2]]  (of type T)

TODO : when d is not small

===============================================================================
CD[DL(E)] : create a delay line and write signal
===============================================================================
       r = rate(DL(E)) = rate(E)
       T = type(DL(E)) = type(E)
       d = maxdelay(DL(E))

-------------------------------------------------------------------------------
CD[DL(E)] : E ==> V
-------------------------------------------------------------------------------

if d is small :

+	T M[d]
+	T RM[r*VS + d]
+	T* R = addr(RM[d])
+	Loop(j, d) {
+       RM[j] = M[j]
+	}
+	Loop(j, r*VS) {
+       CA[addr(R[j]), E, j)
+	}
+	Loop(j, d) {
+       M[j] = RM[r*VS+j]
+	}

>   R  (of type T[r*VS])

TODO : when d is not small
