===============================================================================
SPECIFICATION OF MULTI-RATE COMPILATIONS RULES
===============================================================================

Types definition
T = int | float | T[n]

E : signal expression
E = INx | P(E1,..) | NUM(x) | vectorize(n,E) | serialize(E) | E1#E2 | E1[E2] | DL(E1)@E2 | PROJ(n, g = (E0, E1, ...))

V : compilation value
V = int | float | var | V[n] | P(V1,..)

S : compilation statement
S : Store(A, V, I) | Loop(i, n) { S* } | SubLoop(i, n) { S* }

I : access indexes
I : int | var | Binop(i1, i2) | I* (with Binop : +,-,*,/)

A compilation value V has a type given with type(V) = T

addr(T)     : address with some type T
cast(T,A)   : cast the address with the type T

In each compilation rule:

- the "+" symbol means "adding a statement in the current loop"
- the ">" symbol means "returning a value"

===============================================================================
COMPLEX VERSION WITH DESTINATION AND INDEX
===============================================================================

CTOP[E0, E1...]         = compile each output signal
CV[A, E]                = compile Vector, fill vector A with count*rate samples of signal E, no value
CA[A, OUT_I, E, IN_I]   = compile Assignment, store in A at index OUT_I , the value of signal E at index IN_I, no value
CS[E, IN_I]             = compile Sample, compute the value of signal E at index IN_I, returns a value
CD[DL(E), IN_I]         = create a delay line, write signal, returns the delay line

VS = vector size
count = implicit parameter indicating how many samples at rate 1 we will compute
count <= VS

-------------------------------------------------------------------------------
CTOP[E0, E1, E2, ...] = compile each output signal
-------------------------------------------------------------------------------
   	ri = rate(Ei)
   	Ti = int | float = type(Ei)
	Ti[ri*VS] = type(OUTi)

+	CV[OUT0, E0]
+	CV[OUT1, E1]
+	....

-------------------------------------------------------------------------------
CV[A, E] = compile vector, fill vector A with count*rate samples of signal E
-------------------------------------------------------------------------------
   	r = rate(E)
   	T = type(E)
	T[r*VS] = type(A)
	I = fresh index

+	Loop(i, r*count) {
+		CA[A, I, E, I]
+	}


===============================================================================
NUM(x) : number (int or float) of value 'x'
===============================================================================

-------------------------------------------------------------------------------
CA[A, OUT_I, NUM(x), IN_I] : &T x I x E x I ==> void
-------------------------------------------------------------------------------
+	Store(A, CS[NUM(x), IN_I], OUT_I)

-------------------------------------------------------------------------------
CS[NUM(x), IN_I] : E x I x I ==> V
-------------------------------------------------------------------------------
>	x (of type int | float)


===============================================================================
INx : input x
===============================================================================

-------------------------------------------------------------------------------
CA[A, OUT_I, INx, IN_I] : &T x I x E x I ==> void
-------------------------------------------------------------------------------
+	Store(A, CS[INx, IN_I], OUT_I)

-------------------------------------------------------------------------------
CS[INx, IN_I]: E x I x I ==> V
-------------------------------------------------------------------------------
>	INx[IN_I] (of type int | float)


===============================================================================
P(E1,E2,..) : primitive operation on signals
===============================================================================
	r = rate(P(E1,E2,..))
	T = type(P(E1,E2,..))

-------------------------------------------------------------------------------
CA[A, OUT_I, P(E1,E2,..), IN_I] : &T x I x E x I ==> void
-------------------------------------------------------------------------------
+	Store(A, CS[P(E1,E2,..), IN_I], OUT_I)

-------------------------------------------------------------------------------
CS[P(E1,..), IN_I] : E x I x I ==> V
-------------------------------------------------------------------------------
	j is a fresh loop index

if not shared (P(E1,E2,..)) : we can inline the expression

>	P(CS[E1,IN_I],CS[E2,IN_I],...)

if shared (P(E1,E2,..)) : we need an intermediate buffer W to store
+ 	T 	W[r*VS]
+	Loop(j, r*count) {
+		W[j] = P(CS[E1,j],...)
+	}

>	W[IN_I]  (of type T)


===============================================================================
vectorize(n,E) : create a signal of vectors of size n and rate r/n
===============================================================================
       n*m = rate(E)
   	     T = type(E)

 	     m = rate(vectorize(n,E))
      T[n] = type(vectorize(n,E))

-------------------------------------------------------------------------------
CA[A, OUT_I, vectorize(n,E), IN_I] : &T x I x E x I ==> void
-------------------------------------------------------------------------------
	k is a fresh loop index

if not shared (vectorize(n,E)) :

+	SubLoop(k, n) {
+		CA[A, (OUT_I, k), E, I*n+k]   (was addr(A[k]) : here we add k in the list of OUT_I)
+ 	}

if shared (vectorize(n,E)) :

+	Store(A, CS[vectorize(n,E),IN_I], OUT_I)


-------------------------------------------------------------------------------
CS[vectorize(n,E),IN_I] : E x I x I ==> V
-------------------------------------------------------------------------------
	j and k are fresh loop indexes

+	T[n] W[m*VS]
+	Loop(j, m*VS) {
+		SubLoop(k, n) {
+			CA[addr(W), (j, k), E, j*n+k]   (was addr(W[j][k]) : here we add j and k for OUT_I)
+		}
+	}

>	W[IN_I] (of type T[n])

===============================================================================
serialize(E) : serialize a signal of vectors
===============================================================================
     m = rate(E)
  T[n] = type(E)

   n.m = rate(serialize(E))
     T = type(serialize(E))

-------------------------------------------------------------------------------
CA[A, OUT_I, serialize(E), IN_I] : &T x I x E x I ==> void
-------------------------------------------------------------------------------

if not shared (serialize(E)) :

+   if (IN_I%n == 0) {
+       CA[cast(T[n],A), OUT_I, E, IN_I/n]  (here we "divide" IN_I by n..)
+   }

if shared (serialize(E)) :

+   Store(A, CS[serialize(E),IN_I], OUT_I)

-------------------------------------------------------------------------------
CS[serialize(E), IN_I] : E x I x I ==> V
-------------------------------------------------------------------------------
    j and k are fresh loop indexes

+	T W[n*m*VS]
+	Loop(j, m*VS) {
+		SubLoop(k, n) {
+			CA[addr(W), j*n+k, E, (j,k)]		(was : W[j*n+k] = CS[E,j][k])
+		}
+	}

> W[IN_I] (of type T)


===============================================================================
E1#E2 : concatenate two signals of vectors
===============================================================================
       r = rate(E1#E2) = rate(E1) = rate(E2)
    T[n] = type(E1)
    T[m] = type(E2)
  T[n+m] = type(E1#E2)

-------------------------------------------------------------------------------
CA[A, OUT_I, E1#E2, IN_I] : &T x I x E x I ==> void
-------------------------------------------------------------------------------

if not shared (E1#E2) :

+	CA[A, OUT_I, E1, IN_I]
+	CA[A, OUT_I+n, E2, IN_I]  (here we "move" OUT_I by n..)

if shared (E1#E2) :

+	Store(A, CS[E1#E2, IN_I], OUT_I)

-------------------------------------------------------------------------------
CS[E1#E2, IN_I] : E x I x I ==> V
-------------------------------------------------------------------------------
	j and k are fresh loop indexes

+	T[n+m] W[r*VS]
+	Loop(j, r*VS) {
+		SubLoop(k, n) {
+           CA[addr(W), (j,k), E1, (j,k)]	(was W[j][k] = CS[E1,j][k])
+       }
+		SubLoop(k, n) {
+           CA[addr(W), (j,n+k), E2, (j,k)]	(was W[j][n+k] = CS[E2,j][k])
+       }
+   }

>   W[IN_I]  (of type T[n+m])


===============================================================================
E1[E2] : takes value of a signal at a given index
===============================================================================
       r = rate(E1[E2]) = rate(E1) = rate(E2)
    T[n] = type(E1)
     int = type(E2) in (0, n-1)
       T = type(E1[E2])

-------------------------------------------------------------------------------
CA[A, OUT_I, E1[E2], IN_I] : &T x I x E x I ==> void
-------------------------------------------------------------------------------

+   Store(A, CS[E1[E2],IN_I], OUT_I)

-------------------------------------------------------------------------------
CS[E1[E2], IN_I] : E x I x I ==> V
-------------------------------------------------------------------------------

>   CS[E1,IN_I][CS[E2,IN_I]]  (of type T)


===============================================================================
PROJ(n, g = (E0, E1, ...)) : projection of a recursive group
===============================================================================
       r = rate(E0) = rate(E1) = ...
      T0 = type(E0), T1 = type(E1), ...
      m0 = maxdelay(E0), m1 = maxdelay(E1), ...

-------------------------------------------------------------------------------
CA[A, OUT_I, PROJ(n, g = (E0, E1, ...)), IN_I] : &T x I x E x I ==> void
-------------------------------------------------------------------------------

+   Store(A, CS[PROJ(n, g = (E0, E1, ...)),IN_I], OUT_I)

-------------------------------------------------------------------------------
CS[PROJ(n, g = (E0, E1, ...)), IN_I] : E x I x I ==> V
-------------------------------------------------------------------------------
       r = rate(E0) = rate(E1) = ...
      T0 = type(E0), T1 = type(E1), ...
      m0 = maxdelay(E0), m1 = maxdelay(E1), ...

+	T0 W0[r*VS + m0]
+	T1 W1[r*VS + m1]
+   ....
+	Loop(j, m*VS) {
+       CA[addr(W0), i, E0, i]
+       CA[addr(W1), i, E1, i]
+       ....
+	}

>   Wn[IN_I] (of type Tn)


===============================================================================
DL(E1)@E2 : read in a delay line
===============================================================================
       r = rate(DL(E1)@E2) = rate(DL(E1)) = rate(E1) = rate(E2)
       T = type(DL(E1)) = type(E1)
     int = type(E2)
       d = maxdelay(DL(E1))

-------------------------------------------------------------------------------
CA[A, OUT_I, DL(E1)@E2, IN_I] : &T x I x E x I ==> void
-------------------------------------------------------------------------------

+   Store(A, CS[DL(E1)@E2, IN_I], OUT_I)

-------------------------------------------------------------------------------
CS[DL(E1)@E2, IN_I] : E x I x I ==> V
-------------------------------------------------------------------------------

if d is small :
+   W = CD[DL(E1),IN_I]

>   W[IN_I-CS[E2,IN_I]]  (of type T)

TODO : when d is not small


===============================================================================
CD[DL(E), IN_I] : create a delay line and write signal
===============================================================================
       r = rate(DL(E)) = rate(E)
       T = type(DL(E)) = type(E)
       d = maxdelay(DL(E))

-------------------------------------------------------------------------------
CD[DL(E), IN_I] : E x I x I ==> V
-------------------------------------------------------------------------------

if d is small :

+	T M[d]
+	T RM[r*VS + d]
+	T* R = addr(RM[d])
+	Loop(j, d) {
+       RM[j] = M[j]
+	}
+	Loop(j, r*VS) {
+       CA[addr(RM), d+j, E, j)   (was : addr(R[j])
+	}
+	Loop(j, d) {
+       M[j] = RM[r*VS+j]
+	}

>   R  (of type T[r*VS])

TODO : when d is not small
