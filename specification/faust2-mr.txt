===============================================================================
SPECIFICATION OF MULTI-RATE COMPILATIONS RULES
===============================================================================

Types definition
T = int | float | T[n]

E : signal expression
E = InX | P(E1,..) | Num(x) | Vectorize(n,E) | Serialize(E) | E1#E2 | E1[E2] | DL(E1)@E2 | Proj(n, g = (E0, E1, ...))

V : compilation value
V = int | float | Load(A, I) | P(V1,..)

S : compilation statement
S : Store(A, V, I) | Loop(i, n) { S* } | SubLoop(i, n) { S* }

I : access indexes
I : int | Var(string) | Binop(i1, i2) | I*      (with Binop : +,-,*,/)

A : (string, T)

A compilation value V has a type given with type(V) = T

cast(T,A) : cast the vector with the type T

In each compilation rule:

- the "+" symbol means "adding a statement in the current loop"
- the ">" symbol means "returning a value"

===============================================================================
COMPLEX VERSION WITH DESTINATION AND INDEX
===============================================================================

CTOP[E0, E1...]         = compile each output signal
CV[O, E]                = compile Vector, fill vector O with count*rate samples of signal E, no value
CA[O, OUT_I, E, IN_I]   = compile Assignment, store in O at index OUT_I , the value of signal E at index IN_I, no value
CS[E, IN_I]             = compile Sample, compute the value of signal E at index IN_I, returns a value
CD[DL(E), IN_I]         = create a delay line, write signal, returns the delay line

VS = vector size
count = implicit parameter indicating how many samples at rate 1 we will compute
count <= VS

-------------------------------------------------------------------------------
CTOP[E0, E1, E2, ...] = compile each output signal
-------------------------------------------------------------------------------
   	ri = rate(Ei)
   	Ti = int | float = type(Ei)
	Ti[ri*VS] = type(OUTi)

+	CV[OUT0, E0]
+	CV[OUT1, E1]
+	....

-------------------------------------------------------------------------------
CV[O, E] = compile vector, fill vector O with count*rate samples of signal E
-------------------------------------------------------------------------------
   	r = rate(E)
   	T = type(E)
	T[r*VS] = type(A)
	I = fresh index

+	Loop(i, r*count) {
+		CA[O, I, E, I]
+	}


===============================================================================
Num(x) : number (int or float) of value 'x'
===============================================================================

-------------------------------------------------------------------------------
CA[O, OUT_I, Num(x), IN_I] : A x I x E x I ==> void
-------------------------------------------------------------------------------
+	Store(A, CS[Num(x), IN_I], OUT_I)

-------------------------------------------------------------------------------
CS[Num(x), IN_I] : E x I x I ==> V
-------------------------------------------------------------------------------
>	x (of type int | float)


===============================================================================
InX : input x
===============================================================================

-------------------------------------------------------------------------------
CA[O, OUT_I, InX, IN_I] : A x I x E x I ==> void
-------------------------------------------------------------------------------
+	Store(O, CS[InX, IN_I], OUT_I)

-------------------------------------------------------------------------------
CS[InX, IN_I]: E x I x I ==> V
-------------------------------------------------------------------------------
>	Load(InX, IN_I) (of type int | float)


===============================================================================
P(E1,E2,..) : primitive operation on signals
===============================================================================
	r = rate(P(E1,E2,..))
	T = type(P(E1,E2,..))

-------------------------------------------------------------------------------
CA[O, OUT_I, P(E1,E2,..), IN_I] : A x I x E x I ==> void
-------------------------------------------------------------------------------
+	Store(O, CS[P(E1,E2,..), IN_I], OUT_I)

-------------------------------------------------------------------------------
CS[P(E1,..), IN_I] : E x I x I ==> V
-------------------------------------------------------------------------------
	j is a fresh loop index

if not shared (P(E1,E2,..)) : we can inline the expression

>	P(CS[E1,IN_I],CS[E2,IN_I],...)

if shared (P(E1,E2,..)) : we need an intermediate buffer W to store
+ 	T 	W[r*VS]
+	Loop(j, r*count) {
+		Store(W, P(CS[E1,j],...), j)    (was W[j] = P(CS[E1,j],...))
+	}

>	Load(W, IN_I)  (of type T)


===============================================================================
Vectorize(n,E) : create a signal of vectors of size n and rate r/n
===============================================================================
       n*m = rate(E)
   	     T = type(E)

 	     m = rate(Vectorize(n,E))
      T[n] = type(Vectorize(n,E))

-------------------------------------------------------------------------------
CA[O, OUT_I, Vectorize(n,E), IN_I] : A x I x E x I ==> void
-------------------------------------------------------------------------------
	k is a fresh loop index

if not shared (Vectorize(n,E)) :

+	SubLoop(k, n) {
+		CA[O, (OUT_I, k), E, I*n+k]   (was addr(A[k]) : here we add k in the list of OUT_I)
+ 	}

if shared (Vectorize(n,E)) :

+	Store(O, CS[Vectorize(n,E),IN_I], OUT_I)


-------------------------------------------------------------------------------
CS[Vectorize(n,E),IN_I] : E x I x I ==> V
-------------------------------------------------------------------------------
	j and k are fresh loop indexes

+	T[n] W[m*VS]
+	Loop(j, m*VS) {
+		SubLoop(k, n) {
+			CA[W, (j, k), E, j*n+k]   (was addr(W[j][k]) : here we add j and k for OUT_I)
+		}
+	}

>	Load(W, IN_I) (of type T[n])

===============================================================================
Serialize(E) : Serialize a signal of vectors
===============================================================================
     m = rate(E)
  T[n] = type(E)

   n.m = rate(Serialize(E))
     T = type(Serialize(E))

-------------------------------------------------------------------------------
CA[O, OUT_I, Serialize(E), IN_I] : A x I x E x I ==> void
-------------------------------------------------------------------------------

if not shared (Serialize(E)) :

+   if (IN_I%n == 0) {
+       CA[cast(T[n],O), OUT_I, E, IN_I/n]  (here we "divide" IN_I by n..)
+   }

if shared (Serialize(E)) :

+   Store(O, CS[Serialize(E),IN_I], OUT_I)

-------------------------------------------------------------------------------
CS[Serialize(E), IN_I] : E x I x I ==> V
-------------------------------------------------------------------------------
    j and k are fresh loop indexes

+	T W[n*m*VS]
+	Loop(j, m*VS) {
+		SubLoop(k, n) {
+			CA[W, j*n+k, E, (j,k)]		(was : W[j*n+k] = CS[E,j][k])
+		}
+	}

> Load(W, IN_I) (of type T)


===============================================================================
E1#E2 : concatenate two signals of vectors
===============================================================================
       r = rate(E1#E2) = rate(E1) = rate(E2)
    T[n] = type(E1)
    T[m] = type(E2)
  T[n+m] = type(E1#E2)

-------------------------------------------------------------------------------
CA[O, OUT_I, E1#E2, IN_I] : A x I x E x I ==> void
-------------------------------------------------------------------------------

if not shared (E1#E2) :

+	CA[O, OUT_I, E1, IN_I]
+	CA[O, OUT_I+n, E2, IN_I]  (here we "move" OUT_I by n..)

if shared (E1#E2) :

+	Store(O, CS[E1#E2, IN_I], OUT_I)

-------------------------------------------------------------------------------
CS[E1#E2, IN_I] : E x I x I ==> V
-------------------------------------------------------------------------------
	j and k are fresh loop indexes

+	T[n+m] W[r*VS]
+	Loop(j, r*VS) {
+		SubLoop(k, n) {
+           CA[W, (j,k), E1, (j,k)]	(was W[j][k] = CS[E1,j][k])
+       }
+		SubLoop(k, n) {
+           CA[W, (j,n+k), E2, (j,k)]	(was W[j][n+k] = CS[E2,j][k])
+       }
+   }

>   Load(W, IN_I)  (of type T[n+m])


===============================================================================
E1[E2] : takes value of a signal at a given index
===============================================================================
       r = rate(E1[E2]) = rate(E1) = rate(E2)
    T[n] = type(E1)
     int = type(E2) in (0, n-1)
       T = type(E1[E2])

-------------------------------------------------------------------------------
CA[O, OUT_I, E1[E2], IN_I] : A x I x E x I ==> void
-------------------------------------------------------------------------------

+   Store(O, CS[E1[E2],IN_I], OUT_I)

-------------------------------------------------------------------------------
CS[E1[E2], IN_I] : E x I x I ==> V
-------------------------------------------------------------------------------

>   CS[E1,IN_I][CS[E2,IN_I]]  (of type T)


===============================================================================
Proj(n, g = (E0, E1, ...)) : projection of a recursive group
===============================================================================
       r = rate(E0) = rate(E1) = ...
      T0 = type(E0), T1 = type(E1), ...
      m0 = maxdelay(E0), m1 = maxdelay(E1), ...

-------------------------------------------------------------------------------
CA[O, OUT_I, Proj(n, g = (E0, E1, ...)), IN_I] : A x I x E x I ==> void
-------------------------------------------------------------------------------

+   Store(A, CS[Proj(n, g = (E0, E1, ...)),IN_I], OUT_I)

-------------------------------------------------------------------------------
CS[Proj(n, g = (E0, E1, ...)), IN_I] : E x I x I ==> V
-------------------------------------------------------------------------------
       r = rate(E0) = rate(E1) = ...
      T0 = type(E0), T1 = type(E1), ...
      m0 = maxdelay(E0), m1 = maxdelay(E1), ...

+	T0 W0[r*VS + m0]
+	T1 W1[r*VS + m1]
+   ....
+	Loop(j, m*VS) {
+       CA[W0, i, E0, i]
+       CA[W1, i, E1, i]
+       ....
+	}

>   Load(Wn, IN_I) (of type Tn)


===============================================================================
DL(E1)@E2 : read in a delay line
===============================================================================
       r = rate(DL(E1)@E2) = rate(DL(E1)) = rate(E1) = rate(E2)
       T = type(DL(E1)) = type(E1)
     int = type(E2)
       d = maxdelay(DL(E1))

-------------------------------------------------------------------------------
CA[O, OUT_I, DL(E1)@E2, IN_I] : A x I x E x I ==> void
-------------------------------------------------------------------------------

+   Store(A, CS[DL(E1)@E2, IN_I], OUT_I)

-------------------------------------------------------------------------------
CS[DL(E1)@E2, IN_I] : E x I x I ==> V
-------------------------------------------------------------------------------

if d is small :
+   W = CD[DL(E1),IN_I]

>   Load(W, [IN_I-CS[E2,IN_I]])  (of type T)

TODO : when d is not small


===============================================================================
CD[DL(E), IN_I] : create a delay line and write signal
===============================================================================
       r = rate(DL(E)) = rate(E)
       T = type(DL(E)) = type(E)
       d = maxdelay(DL(E))

-------------------------------------------------------------------------------
CD[DL(E), IN_I] : E x I x I ==> V
-------------------------------------------------------------------------------

if d is small :

+	T M[d]
+	T RM[r*VS + d]
+	T* R = RM[d]
+	Loop(j, d) {
+       Store(RM, Load(addr(M,j), j)
+	}
+	Loop(j, r*VS) {
+       CA[RM, d+j, E, j)   (was : addr(R[j])
+	}
+	Loop(j, d) {
+       Store(M, Load(RM, r*VS+j), j)
+	}

>   R  (of type T[r*VS])

TODO : when d is not small
