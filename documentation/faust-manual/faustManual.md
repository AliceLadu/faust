# Introduction 

## What is Faust?

Faust (Functional Audio Stream) is a functional programming language for sound 
synthesis and audio processing with a strong focus on the design of 
synthesizers, musical instruments, audio effects, etc. Faust targets 
high-performance signal processing applications and audio plug-ins for 
a variety of platforms and standards. It is used on stage for concerts and 
artistic productions, in education and research, in open source projects as 
well as in commercial applications.

The core component of Faust is its compiler. It allows to "translate" any Faust 
digital signal processing (DSP) specification to a wide range of non-domain 
specific languages such as C++, C, JAVA, JavaScript, LLVM bit code, WebAssembly, 
etc. In this regard, Faust can be seen as an alternative to C++ but is much 
simpler and intuitive to learn. 

Thanks to a wrapping system called "architectures," codes generated by Faust 
can be easily compiled into a wide variety of objects ranging from 
[audio plug-ins](TODO-tutorial) to [standalone applications](TODO-tutorial) or 
[smartphone](TODO-tutorial) and [web apps](TODO-tutorial), etc. (check the 
[Quick Tour of the Faust Targets](#a-quick-tour-of-the-faust-targets) section
for an exhaustive list.

This manual gives an overview of the Faust programming language and of its 
features through various interactive examples.

## What is Faust Good For?

Faust's syntax allows to express any DSP algorithm as a block diagram. For 
example, `+` is considered as a valid function (and block) taking two arguments 
(signals) and returning one:

<!-- faust-run -->
```
process = +;
```
<!-- /faust-run -->

Blocks can be easily connected together using the `:` "connection" composition:

<!-- faust-run -->
```
process = + : *(0.5);
```
<!-- /faust-run -->

In that case, we add two signals together and then scale the result of this 
operation.

Thus, **Faust is perfect to implement time-domain algorithms that can be easily 
represented as block diagrams** such as filters, waveguide physical models, 
virtual analog elements, etc.

**Faust is very concise**, for example, here's the implementation of a one pole 
filter/integrator equivalent to $y(n) = x(x) + a_{1}y(n-1)$ (where $a_{1}$ is 
the pole):

<!-- faust-run -->
```
a1 = 0.9;
process = +~*(a1);
```
<!-- /faust-run -->

**Codes generated by Faust are extremely optimized** and usually more efficient 
that handwritten codes (at least for C and C++). The Faust compiler tries to 
optimize each element of an algorithm. For example, you shouldn't have to 
worry about using divides instead of multiplies as they get automatically 
replaced by multiplies by the compiler when possible, etc.

**Faust is very generic** and allows to write code that will run on dozens of 
platforms.

<!-- If we stick to this, we should also talk about the web capabilities: in
other words be a bit more specific here. -->

## What is Faust Not (So) Good For?

Despite all this, Faust does have some limitations. For instance, it doesn't 
allow for the efficient implementation of algorithms requiring multi-rates such 
as the FFT, convolution, etc. While there are tricks to go around this issue, 
we're fully aware that it is a big one and we're working as hard as possible on 
it.

Faust's conciseness can sometimes become a problem too, especially for complex 
algorithms with lots of recursive signals. It is usually crucial in Faust to 
have the "mental global picture" of the algorithm to be implemented which in 
some cases can be hard.

While the Faust compiler is relatively bug-free, it does have some limitations 
and might get stuck in some extreme cases that you will probably never 
encounter. If you do, [shoot us an e-mail](https://sourceforge.net/p/faudiostream/mailman/)!

From here, you can jump to ... if you wanna get your hands dirty, etc. TODO.

## Design Principles

Since the beginning of its development in 2002, Faust has been guided by
various design principles:

* Faust is a *specification language*. It aims at providing an adequate 
notation to describe *signal processors* from a mathematical point of view. 
Faust is, as much as possible, free from implementation details. 
* Faust programs are fully compiled (i.e., not interpreted). The compiler 
translates Faust programs into equivalent programs in other languages (e.g., 
JAVA, JavaScript, LLVM bit code, WebAssembly, etc.) taking care of generating 
the most efficient code. The result can generally compete with, and sometimes 
even outperform, C++ code written by seasoned programmers. 
* The generated code works at the sample level. It is therefore suited to 
implement low-level DSP functions like recursive filters. Moreover the code can 
be easily embedded. It is self-contained and doesn't depend of any DSP library 
or runtime system. It has a very deterministic behavior and a constant memory 
footprint. 
* The semantic of Faust is simple and well defined. This is not just of 
academic interest. It allows the Faust compiler to be *semantically driven*. 
Instead of compiling a program literally, it compiles the mathematical function 
it denotes. This feature is useful for example to promote components reuse 
while preserving optimal performance.  
* Faust is a textual language but nevertheless block-diagram oriented. It 
actually combines two approaches: *functional programming* and *algebraic 
block-diagrams*. The key idea is to view block-diagram construction as function 
composition. For that purpose, Faust relies on a *block-diagram algebra* of 
five composition operations: `: , ~ <: :>` (see the section on 
[Diagram Composition Operations](#diagram-composition-operations) for more
details).
* Thanks to the concept of *architecture*, Faust programs can be easily 
deployed on a large variety of audio platforms and plugin formats without any 
change to the Faust code.

## Signal Processor Semantic

A Faust program describes a *signal processor*. The role of a *signal processor* 
is to transforms a (possibly empty) group of *input signals* in order to 
produce a (possibly empty) group of *output signals*. Most audio equipments can 
be modeled as *signal processors*. They have audio inputs, audio outputs as 
well as control signals interfaced with sliders, knobs, vu-meters, etc. 

More precisely :

* A *signal* $s$ is a discrete function of time 
$s:\mathbb{Z}\rightarrow\mathbb{R}$. The value of a signal $s$ at time $t$ is 
written $s(t)$. The values of signals are usually needed starting from time $0$. 
But to take into account *delay operations*, negative times are possible and 
are always mapped to zeros. Therefore for any Faust signal $s$ we have 
$\forall t<0, s(t)=0$. In operational terms this corresponds to assuming that 
all delay lines are signals initialized with $0$s. 
* Faust considers two type of signals: *integer signals* 
($s:\mathbb{Z}\rightarrow\mathbb{Z}$) and *floating point signals* 
($s:\mathbb{Z}\rightarrow\mathbb{Q}$). Exchanges with the outside world are, by 
convention, made using floating point signals. The full range is represented by 
sample values between $-1.0$ and $+1.0$.
* The set of all possible  signals is $\mathbb{S}=\mathbb{Z}\rightarrow\mathbb{R}$.
* A group of $n$ signals (a *n*-tuple of signals) is written 
$(s_{1},\ldots,s_{n})\in \mathbb{S}^{n}$. The *empty tuple*, single element of 
$\mathbb{S}^{0}$ is notated $()$.
* A *signal processors* $p$, is a function from *n*-tuples of signals to 
*m*-tuples of signals $p:\mathbb{S}^{n}\rightarrow\mathbb{S}^{m}$. The set 
$\mathbb{P}=\bigcup_{n,m}\mathbb{S}^{n}\rightarrow\mathbb{S}^{m}$ is the
set of all possible signal processors.

As an example, let's express the semantic of the Faust primitive `+`. Like any 
Faust expression, it is a signal processor. Its signature is
$\mathbb{S}^{2}\rightarrow\mathbb{S}$. It takes two input signals $X_0$ and 
$X_1$ and produces an output signal $Y$ such that $Y(t) = X_0(t)+X_1(t)$. 

Numbers are signal processors too. For example the number $3$ has signature  $\mathbb{S}^{0}\rightarrow\mathbb{S}$. It takes no input signals and produce an 
output signal $Y$ such that $Y(t) = 3$. 

# Quick Start

TODO Will be all based on the online editor... May be could be a simple copy and
paste of the session 1 of the Kadenze course...

# Overview of the Faust Universe

While in its most *primitive* form, Faust is distributed as a command-line 
compiler, a wide range of tools have been developed around it in the course of 
the past few years. Their variety and their function might be hard to grab at 
first. This sort chapter provides an overview of their role and will hopefully 
help you decide which one is better suited for your personal use. 

<!-- TODO: it'd be nice to have some kind of figure here summarizing everything -->

TODO: here say a few words about the philosophy behind the disto: the online
editor is the way to go for most users, then various pre-compiled packages
of the compiler can be found, then source, then git. Finally other external
tools for development.   

## The Faust Distribution

The Faust distribution hosts the source of the Faust compiler (both in its 
command line and library version), the source of the Faust *architectures*
(targets), the various Faust compilation scripts, a wide range of 
Faust-related-tools, the [Faust DSP Libraries](TODO) (which in practice
are hosted a separate Git submodule), etc.

The latest stable release of the Faust distribution can be found here:
<https://github.com/grame-cncm/faust/releases>. It is recommended for most
Faust users willing to compile the Faust compiler and `libfaust` from scratch.

To have the latest stable development version, you can use the `master`
branch of the Faust git repository which is hosted on GitHub: 
<https://github.com/grame-cncm/faust/tree/master>.

For something even more bleeding edge (to be used at your own risks), you might
use the `master-dev` branch of the Faust git repository: 
<https://github.com/grame-cncm/faust/tree/master-dev>. `master-dev` is the 
development sub-branch of `master`. It is used by Faust developers to commit 
their changes and can be considered as "the main development branch." The goal 
is to make sure that `master` is always functional. Merges between `master-dev` 
and `master` are carried out multiple times a week by the GRAME team.

> Also, note that pre-compiled packages of the Faust compiler and of `libfaust`
for various platforms can be found on the [Download Page](__FAUST_DOMAIN__/download)
of the Faust website.

The Faust distribution is organized as follows:

```
architecture/          : the source of the architecture files
benchmark/             : tools to measure the efficiency of the generated code
build/                 : the various makefiles and build folders
compiler/              : sources of the Faust compiler
COPYING                : license information
debian/                : files for Debian installation
Dockerfile             : docker file
documentation/         : Faust's documentations
examples/              : Faust programs examples organized by categories
installer/             : various installers for Linux distribution
libraries/             : Faust DSP libraries
Makefile               : makefile used to build and install Faust
README.md              : instructions on how to build and install Faust
syntax-highlighting/   : support for syntax highlighting for several editors
tests/                 : various tests
tools/                 : tools to produce audio applications and plugins
windows/               : Windows related ressources
```

The following subsections present some of the main components of the Faust 
distribution.

### Command-Line Compiler

* Link to precompiled version versions (download page)
* What is the Faust compiler? (Quickly)
* Link to [Using the Faust Compiler](#using-the-faust-compiler)

### `libfaust`

* Link to precompiled version versions (download page)
* What is it? (Quickly)
* Link to tutorial 
[Embedding the Faust Compiler Using `libfaust`](__FAUST_DOMAIN__/learn/embedding-faust)

### `faust2...` Scripts

## Web Tools

### The Online Editor

### The FaustPlayground

### The Faust Online Compiler

### Web Services

## Development Tools

### FaustLive

### FaustWorks

# Compiling and Installing Faust

This chapter describes how to get and compile the Faust compiler as well as
other tools related to Faust (e.g., [`libfaust`](#libfaust), `libosc`, 
`libhttpd`, etc.). 

## Getting the Source Code

An overview of the various places where the Faust source can be downloaded is
given [here](#the-faust-distribution). 

If you downloaded the latest Faust release, just un-compressed the archive 
file and open it in a terminal. For instance, something like (this might vary 
depending on the version of Faust you downloaded):

```
tar xzf faust-2.5.31.tar.gz
cd faust-2.5.31
``` 

If you wish to get the Faust source directly from the git repository, just
run:

```
git clone --recursive https://github.com/grame-cncm/faust.git
cd faust
```

in a terminal. Note that the `--recursive` option is necessary here since some 
elements (e.g., the Faust DSP libraries) are placed in other repositories.

Finally, if you wish to use the development (and potentially unstable) branch, 
just run:

```
git checkout master-dev
```

after the previous 2 commands.

TODO: see with Dominique for whatever comes next here...

Since release 2.5.18, Faust compilation and installation is based on `cmake`.


# Faust Syntax

<!-- TODO we should make a new introductory figure here and add some comments
about it. It'd be nice to make it interactive so that when people click on it,
they are brought to the right section. -->

## Faust Program

A Faust program is essentially a list of *statements*. These statements can be 
[*metadata declarations*](#metadata-declarations), [*imports*](#imports), 
[*definitions*](#definitions), and [*documentation tags*](#documentation-tags), 
with optional C++ style (`//...` and `/*...*/`) comments.

Here is a short Faust program that implements of a simple noise generator 
(called from the `noises.lib` Faust library). It exhibits various kind of 
statements : two [*metadata declarations*](#metadata-declarations), an 
[*imports*](#imports), a *comment*, and a [*definition*](#definitions). We will 
study later how [*documentation statements*](#documentation-tags) work:

<!-- faust-run -->
```
declare name  "Noise";
declare copyright "(c)GRAME 2018";

import("stdfaust.lib");

// noise level controlled by a slider
process = no.noise * hslider("gain",0,0,1, 0.1);
```
<!-- /faust-run -->

The keyword `process` is the equivalent of `main` in C/C++. Any Faust program, 
to be valid, must at least define `process`.

## Statements

The *statements* of a Faust program are of four kinds: 

* *metadata declarations*, 
* *file imports*, 
* *definitions*,
* *documentation*. 

All statements but *documentation* end with a semicolon `;`. 

### Metadata Declarations

All metadata declaration in Faust start with `declare`. 

When used in the context of Faust program (e.g., `.dsp` file), they are 
followed by a key and a string. For example:

```
declare name "Noise";
```

allows us to specify the name of a Faust program in its whole. 

When used in the context of a library (e.g., `.lib` file), metadata 
declarations can either be "global" (as in the previous example), or associated
to a specific function. In that case, `declare` will be followed by the name 
of the function, a key, and a string. For example:

```
declare add author "John Doe"
add = +;
```

This is very useful when a library has several contributors and that functions
potentially have different license terms. 

Unlike regular comments, metadata declarations will appear in the C++ code 
generated by the Faust compiler. A good practice is to start a Faust program 
with some standard declarations:

```
declare name "MyProgram";
declare author "MySelf";
declare copyright "MyCompany";
declare version "1.00";
declare license "BSD"; 
```

### Imports

File imports allow us to import definitions from other source files.  

For example `import("maths.lib");` imports the definitions of the 
[`maths.lib`](TODO) library.

The most common file to be imported is the `stdfaust.lib` library which gives
access to all the standard Faust libraries from a single point:

<!-- faust-run -->
```
import("stdfaust.lib");
process = os.osc(440); // the "hello world" of computer music
```
<!-- /faust-run -->

### Documentation Tags

Documentation statements are optional and typically used to control the 
generation of the mathematical documentation of a Faust program. This 
documentation system is detailed in the 
[Mathematical Documentation](#mathematical-documentation) chapter. In this 
section we essentially describe the documentation statements syntax.

A documentation statement starts with an opening `<mdoc>` tag and ends with a 
closing `</mdoc>` tag. Free text content, typically in Latex format, can be 
placed in between these two tags. <!-- Why not markdown? -->

<img src="img/documentation.svg" class="mx-auto d-block">

Moreover, optional sub-tags can be inserted in the text content itself to 
require the generation, at the insertion point, of mathematical *equations*, 
graphical *block-diagrams*, Faust source code *listing* and explanation 
*notice*.

<img src="img/equation.svg" class="mx-auto d-block">

The generation of the mathematical equations of a Faust expression can be 
requested by placing this expression between an opening `<equation>` and a 
closing `</equation>` tag. The expression is evaluated within the lexical 
context of the Faust program.

<img src="img/diagram.svg" class="mx-auto d-block">

Similarly, the generation of the graphical block-diagram of a Faust expression 
can be requested by placing this expression between an opening `<diagram>` and 
a closing `</diagram>` tag. The expression is evaluated within the lexical 
context of the Faust program.

<img src="img/metadata.svg" class="mx-auto d-block">

The `<metadata>` tags allow to reference Faust 
[metadata declarations](#metadata-declarations), calling the corresponding 
keyword.

<img src="img/notice.svg" class="mx-auto d-block">

The `<notice/>` empty-element tag is used to generate the conventions used in 
the mathematical equations.

<img src="img/listing.svg" class="mx-auto d-block">

The `<listing/>` empty-element tag is used to generate the listing of the 
Faust program. Its three attributes `mdoctags`, `dependencies`, and 
`distributed` enable or disable respectively `<mdoc>` tags, other files 
dependencies and distribution of interleaved Faust code between 
`<mdoc>` sections.

## Definitions

A *definition* associates an identifier with an expression. Definitions are 
essentially a convenient shortcut avoiding to type long expressions. During 
compilation, more precisely during the evaluation stage, identifiers are 
replaced by their definitions. It is therefore always equivalent to use an 
identifier or directly its definition. Please note that multiple definitions of 
a same identifier are not allowed, unless it is a pattern matching based 
definition.

### Simple Definitions

The syntax of a simple definition is:

```
identifier = expression ;
```

For example here is the definition of `random`, a simple pseudo-random number 
generator:

```
random = +(12345) ~ *(1103515245);
```

## Function Definitions

Definitions with formal parameters correspond to functions definitions.

<img src="img/listing.svg" class="mx-auto d-block">

For example the definition of `linear2db`, a function that converts linear 
values to decibels, is:

```
linear2db(x) = 20*log10(x);
```
 
Please note that this notation is only a convenient alternative to the direct 
use of [*lambda-abstractions*](#abstractions) (also called anonymous 
functions). The following is an equivalent definition of `linear2db` using a 
lambda-abstraction:

```
linear2db = \(x).(20*log10(x));
```

## Definitions with pattern matching

Moreover, formal parameters can also be full expressions representing patterns. 

<img src="img/listing.svg" class="mx-auto d-block">

This powerful mechanism allows to algorithmically create and manipulate block 
diagrams expressions. Let's say that you want to describe a function to 
duplicate an expression several times in parallel:

```
duplicate(1,x) = x;
duplicate(n,x) = x, duplicate(n-1,x);
```

Note that this last definition is a convenient alternative to the more verbose:

```
duplicate = case { 
  (1,x) => x; 
  (n,x) => duplicate(n-1,x); 
};
```

A use case for `duplicate` could be to put 5 white noise generators in 
parallel:

<!-- faust-run -->
```
import("stdfaust.lib");
duplicate(1,x) = x;
duplicate(n,x) = x, duplicate(n-1,x);
process = duplicate(5,no.noise);
```
<!-- /faust-run -->

Here is another example to count the number of elements of a list. Please note 
that we simulate lists using [parallel composition](#parallel-composition): 
`(1,2,3,5,7,11)`. The main limitation of this approach is that there is no 
empty list. Moreover lists of only one element are represented by this element:

```
count((x,xs)) = 1+count(xs);
count(x) = 1;
```

If we now write `count(duplicate(10,666))`, the expression will be evaluated as 
`10`.

Note that the order of pattern matching rules matters. The more specific rules 
must precede the more general rules. When this order is not respected, as in:

```
count(x) = 1;
count((x,xs)) = 1+count(xs);
```

the first rule will always match and the second rule will never be called.

## Expressions

Despite its textual syntax, Faust is conceptually a block-diagram language. 
Faust expressions represent DSP block-diagrams and are assembled from primitive 
ones using various *composition* operations. More traditional *numerical* 
expressions in infix notation are also possible. Additionally Faust provides 
time based expressions, like delays, expressions related to lexical 
environments, expressions to interface with foreign function and lambda 
expressions.

<img src="img/expression.svg" class="mx-auto d-block">

### Diagram Expressions

Diagram expressions are assembled from primitive ones using either binary 
composition operations or high level iterative constructions.

<img src="img/diagramexp.svg" class="mx-auto d-block">

#### Diagram Composition Operations 

Five binary *composition operations* are available to combine block-diagrams: 

* [*recursion*](#recursion-composition) (`~`),
* [*parallel*](#parallel-composition) (`,`),
* [*sequential*](#sequential-composition) (`:`),
* [*split*](#split-composition) (`<:`),
* [*merge*](#merge-composition) (`:>`).

One can think of each of these composition operations as a particular way to 
connect two block diagrams. 

<img src="img/diagcomposition.svg" class="mx-auto d-block">

To describe precisely how these connections are done, we have to introduce some 
notation. The number of inputs and outputs of a block-diagram $A$ are expressed 
as $\mathrm{inputs}(A)$ and $\mathrm{outputs}(A)$. The inputs and outputs 
themselves are respectively expressed as: $[0]A$, $[1]A$, $[2]A$, $\ldots$ and 
$A[0]$, $A[1]$, $A[2]$, etc. 

For each composition operation between two block-diagrams $A$ and $B$ we will 
describe the connections $A[i]\rightarrow [j]B$ that are created and the 
constraints on their relative numbers of inputs and outputs.

The priority and associativity of this five operations are:

| Syntax                     | Priority  | Association  | Description             |
| -------------------------- | --------- | ------------ | ----------------------- |
| `expression ~ expression`  | 4         | left         | Recursive Composition   |
| `expression , expression`  | 3         | right        | Parallel Composition    |
| `expression : expression`  | 2         | right        | Sequential Composition  |
| `expression <: expression` | 1         | right        | Split Composition       |
| `expression :> expression` | 1         | right        | Merge Composition       |

#### Parallel Composition

The *parallel composition* (e.g., `(A,B)`) is probably the simplest one. It 
places the two block-diagrams one on top of the other, without connections. The 
inputs of the resulting block-diagram are the inputs of `A` and `B`. The outputs 
of the resulting block-diagram are the outputs of `A` and `B`. 

*Parallel composition* is an associative operation: `(A,(B,C))` and `((A,B),C)` 
are equivalents. When no parenthesis are used (e.g., `A,B,C,D`), Faust uses 
right associativity and therefore builds internally the expression 
`(A,(B,(C,D)))`. This organization is important to know when using pattern 
matching techniques on parallel compositions. 

**Example**

*Parallel composition* can be used to put 3 oscillators of different kinds
and frequencies in parallel, which will result in a Faust program with 3 
outputs:

<!-- faust-run -->
```
import("stdfaust.lib");
process = os.osc(440),os.sawtooth(550),os.triangle(660);
```
<!-- /faust-run -->

*Parallel composition* can be used to easily turn a mono effect into a stereo
one which will result in a Faust program with 2 inputs and 2 outputs:

<!-- faust-run -->
```
import("stdfaust.lib");
level = 1;
process = ve.autowah(level),ve.autowah(level);
```
<!-- /faust-run -->

Note that there's a better to write this last example using the 
[`par` iteration](#par-iteration): 

<!-- faust-run -->
```
import("stdfaust.lib");
level = 1;
process = par(i,2,ve.autowah(level));
```
<!-- /faust-run -->

#### Sequential Composition

#### Split Composition

#### Merge Composition

#### Recursive Composition

#### Inputs and Outputs of an Expression

#### Iterations 

### Infix Notation and Other Syntax Extensions

#### Math Operators

#### Bitwise Operators

#### Comparison

#### Delay

#### Prefix Notation

#### Partial Application

### Time Expressions

#### `@` Operator

#### `'` Operator 

### Environment Expressions

#### `with`

#### `letrec`

#### `environment`

#### Access

#### `library`

<!-- TODO: import? -->

#### `component`

#### Explicit Substitution

### Foreign Expressions

#### `ffunction`

#### Signature

#### Types

#### Variables and Constants

#### File Include

#### Library File

### Applications and Abstractions

#### Abstractions 

#### Applications

#### Pattern Matching

## Primitives

# Using the Faust Compiler

# A Quick Tour of the Faust Targets

# Mathematical Documentation
