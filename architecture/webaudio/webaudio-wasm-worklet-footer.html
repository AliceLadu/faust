
<script>

'use strict';

// Faust part

var isWasm = (typeof(WebAssembly) !== "undefined");
var isWebKitAudio = (typeof (webkitAudioContext) !== "undefined");
var context = (isWebKitAudio) ? new webkitAudioContext() : new AudioContext();
var factory = null;
var node = null;

function workletAvailable()
{
    if (typeof (OfflineAudioContext) === "undefined") return false;
    var context = new OfflineAudioContext(1, 1, 44100);
    return context.audioWorklet && typeof context.audioWorklet.addModule === 'function';
}

// MIDI input handling

function pitchWheel(channel, wheel)
{
    if (node) {
        node.pitchWheel(channel, wheel);
    }
}

function ctrlChange(channel, ctrl, value)
{
    if (node) {
        node.ctrlChange(channel, ctrl, value);
    }
}

function midiMessageReceived(ev)
{
    var cmd = ev.data[0] >> 4;
    var channel = ev.data[0] & 0xf;
    var data1 = ev.data[1];
    var data2 = ev.data[2];

    if (channel === 9) {
        return;
    } else if (cmd === 11) {
        ctrlChange(channel, data1, data2);
    } else if (cmd === 14) {
        pitchWheel(channel, ((data2 * 128.0 + data1)-8192)/8192.0);
    }
}

function onerrorcallback(error) {
    console.log(error);
}

function onsuccesscallbackStandard(access) {
    
    access.onstatechange = function(e) {
        if (e.port.type === "input") {
            if (e.port.state === "connected") {
                console.log(e.port.name + " is connected");
                e.port.onmidimessage = midiMessageReceived;
            } else if (e.port.state  === "disconnected") {
                console.log(e.port.name + " is disconnected");
                e.port.onmidimessage = null;
            }
        }
    }
    
    for (var input of access.inputs.values()) {
        input.onmidimessage = midiMessageReceived;
        console.log(input.name + " is connected");
    }
}

function activateMIDIInput() {
    console.log("activateMIDIInput");
    if (typeof(navigator.requestMIDIAccess) !== "undefined") {
        navigator.requestMIDIAccess().then(onsuccesscallbackStandard, onerrorcallback);
    } else {
        alert("MIDI input cannot be activated, either your browser still does't have it, or you need to explicitly activate it.");
    }
}

// Audio input handling

function activateAudioInput()
{
    if (!navigator.getUserMedia) {
        navigator.getUserMedia = navigator.webkitGetUserMedia || navigator.mozGetUserMedia;
    }

    if (navigator.getUserMedia) {
        navigator.getUserMedia({audio: { echoCancellation: false }}, getDevice, function(e) {
                               alert('Error getting audio input');
                               console.log(e);
                               });
    } else {
        alert('Audio input API not available');
    }
}

function getDevice(device)
{
    // Connect the input to the destination.
    context.createMediaStreamSource(device).connect(node);
}

// Save/Load functions using local storage
function saveDSP()
{
    if (typeof(Storage) !== "undefined") {
        var params = node.getParams();
        for (var i = 0; i < params.length; i++) {
            localStorage.setItem(params[i], node.getParamValue(params[i]));
        }
    }
}

function loadDSP()
{
    if (typeof(Storage) !== "undefined") {
        var params = node.getParams();
        for (var i = 0; i < params.length; i++) {
            if (localStorage.getItem(params[i])) {
                // Restore DSP state
                node.setParamValue(params[i], Number(localStorage.getItem(params[i])));
                // Restore GUI state
                node.getOutputParamHandler()(params[i], Number(localStorage.getItem(params[i])));
            }
        }
    }
}

function startDSPAux(aw_node)
{
    node = aw_node;

    if (node.getNumInputs() > 0) {
        activateAudioInput();
    }
    
    console.log("startDSPAux");
    console.log(node.parameters);
    
    node.connect(context.destination);
    console.log(node.getJSON());

    // TODO: emcc
    //node.metadata({ declare: function(key, value) { console.log("key = " + key + " value = " + value); }});
    console.log(node.getParams());

    // No polling from the server needed, so use an empty loop
    _f4u$t.main_loop = function() {}

    var faustsvg = $('<div />');
    $('body').append(faustsvg);
    
    node.setOutputParamHandler(_f4u$t.main(node.getJSON(), faustsvg, function(path, val) { node.setParamValue(path, val); }));

    // Load DSP state from local storage
    loadDSP();
}

function startDSP()
{
    startNewDSP();
}

function startNewDSP()
{
     if (isWasm && workletAvailable()) {
        factory = new DSP(context, "");
        factory.load()
        .then((aw_node) => startDSPAux(aw_node))
        .catch((error) => { console.log(error); console.log("Faust mydsp cannot be loaded or compiled"); });
    }  else {
        alert("WebAssembly or AudioWorklet is not supported in this browser !");
    }
}

// To activate audio on iOS
window.addEventListener('touchstart', function() {

                        // create empty buffer
                        var buffer = context.createBuffer(1, 1, 22050);
                        var source = context.createBufferSource();
                        source.buffer = buffer;

                        // connect to output (your speakers)
                        source.connect(context.destination);

                        // play the file
                        source.start();

                        }, false);

// Start monophonic instrument
if (typeof (Module) !== "undefined") {
    console.log("Compiled with EMCC");
    Module['onRuntimeInitialized'] = startDSP;
} else {
    console.log("Compiled with WASM backend");
    activateMIDIInput();
    startDSP();
}

// Save DSP state to local storage
setInterval(function() { if (node) saveDSP(); }, 1000);

</script>
