// filter.lib - digital filters of various types useful in audio and beyond

declare name "Faust Filter Library";
declare author "Julius O. Smith (jos at ccrma.stanford.edu)";
declare copyright "Julius O. Smith III";
declare version "1.2";
declare license "STK-4.3"; // Synthesis Tool Kit 4.3 (MIT style license)
declare reference "http://ccrma.stanford.edu/~jos/filters/";

import("music.lib"); // delay, frac and, from math.lib, SR and PI

//---------------------- zero(z) --------------------------
// z = location of zero along real axis in z-plane
// Difference equation: y(n) = x(n) - z * x(n-1)
// Reference: http://ccrma.stanford.edu/~jos/filters/One_Zero.html

zero(z) =  _ <: _,mem : _,*(z) : -;

//------------------------ pole(p) ---------------------------
// p = pole location = feedback coefficient
// Could also be called a "leaky integrator".
// Difference equation: y(n) = x(n) + p * y(n-1)
// Reference: http://ccrma.stanford.edu/~jos/filters/One_Pole.html

pole(p) = + ~ *(p);

//---------------------- integrator --------------------------
// pole(1) [implemented separately for block-diagram clarity]

integrator = + ~ _ ;

//----------------------- tau2pole ---------------------------
// tau2pole(tau) returns a real pole giving exponential decay with
// tau = time-constant in seconds
//
tau2pole(tau) = exp(-1.0/(tau*SR));

//---------------------- smooth(s) --------------------------
// Exponential smoothing by a unity-dc-gain one-pole lowpass
//
// USAGE: smooth(tau2pole(tau)), where 
//   tau = desired smoothing time constant in seconds,
// or
//   smooth(s), where s = smoothness between 0 and 1.
//    s=0 for no smoothing
//    s=0.999 is "very smooth"
// s>1 is unstable, and s=1 yields the zero signal for all inputs.
// The exponential time-constant is approximately 
// 1/(1-s) samples, when s is close to (but less than) 1.
// Reference: 
// http://ccrma.stanford.edu/~jos/mdft/Convolution_Example_2_ADSR.html

smooth(s) = *(1.0 - s) : + ~ *(s);

//------------------- dcblockerat(fb) -----------------------
// fb = "break frequency" in Hz, i.e., -3 dB gain frequency.
// The amplitude response is substantially flat above fb,
// and sloped at about +6 dB/octave below fb.
// Derived from the analog transfer function 
// H(s) = s / (s + 2*PI*fb) 
// by the low-frequency-matching bilinear transform method
// (i.e., the standard frequency-scaling constant 2*SR).
// Reference:
// http://ccrma.stanford.edu/~jos/pasp/Bilinear_Transformation.html

dcblockerat(fb) = *(b0) : zero(1) : pole(p)
with {
  wn = PI*fb/SR;
  b0 = 1.0 / (1 + wn);
  p = (1 - wn) * b0;
};

//---------------------- dcblocker --------------------------
// Default dc blocker has -3dB point near 35 Hz (at 44.1 kHz)
// and high-frequency gain near 1.0025 (due to no scaling)
//
dcblocker = zero(1) : pole(0.995);

//------------ notchw(width,freq), notch(freq) --------------
// width = "notch width" in Hz (approximate)
// freq  = "notch frequency" in Hz
// Reference:
// http://ccrma.stanford.edu/~jos/pasp/Phasing_2nd_Order_Allpass_Filters.html

notchw(width,freq) = tf2(b0,b1,b2,a1,a2)
with {
  fb = 0.5*width; // First design a dcblockerat(width/2)
  wn = PI*fb/SR;
  b0db = 1.0 / (1 + wn);
  p = (1 - wn) * b0db; // This is our pole radius.
  // Now place unit-circle zeros at desired angles:
  tn = 2*PI*freq/SR;
  a2 = p * p;
  a2p1 = 1+a2;
  a1 = -a2p1*cos(tn);
  b1 = a1;
  b0 = 0.5*a2p1;
  b2 = b0;
};

notch(fb) = notchw(70,fb); // 70 Hz default width (like dcblocker)

//========================= Comb Filters ===============================

//------------------------- ffcombfilter ---------------------------
// Feed-Forward Comb Filter
// 
// USAGE: ffcombfilter(maxdel,del,g), where
//   maxdel = maximum delay (a power of 2)
//   del = current comb-filter delay between 0 and maxdel
//   g = gain applied to delay-line output
//
// Reference: 
//   http://ccrma.stanford.edu/~jos/pasp/Feedforward_Comb_Filters.html

ffcombfilter(maxdel,del,g) = _ <: delay(maxdel,del) : *(g): + ;

//------------------- fbcombfilter, ffbcombfilter -------------------
// Feed-Back Comb Filter
//
// USAGE: fbcombfilter(maxdel,intdel,g), where
//   maxdel = maximum delay (a power of 2)
//   intdel = current comb-filter delay between 0 and maxdel
//   g = gain applied to delay-line output = feedback gain
//
// or, if fractional delay is needed,
//   ffbcombfilter(maxdel,del,g), where del is (non-int) delay
//
// Reference: 
//   http://ccrma.stanford.edu/~jos/pasp/Feedback_Comb_Filters.html

fbcombfilter(maxdel,intdel,g) = (+ : delay(maxdel,intdel)) ~ *(g);
ffbcombfilter(maxdel,del,g) = (+ : fdelay(maxdel,del)) ~ *(g);

//================ Second Order Digital Filter Sections ================

// Specified by transfer-function polynomials B(z)/A(z) as in matlab

//----------------------------- tf1 ---------------------------------
// First-order direct-form digital filter

tf1(b0,b1,a1) = _ <: *(b0), (mem : *(b1)) :> + ~ *(0-a1);

//----------------------------- tf2 ---------------------------------
// Second-order direct-form digital filter.
// This is just a copy of TF2(b0,b1,b2,a1,a2) from Faust's music.lib.

tf2(b0,b1,b2,a1,a2) = sub ~ conv2(a1,a2) : conv3(b0,b1,b2)
with {
  conv3(k0,k1,k2,x)     = k0*x + k1*x' + k2*x'';
  conv2(k0,k1,x)        = k0*x + k1*x';
  sub(x,y)              = y-x;
};

//----------------------------- tf3 ---------------------------------
// Third-order direct-form digital filter

tf3(b0,b1,b2,b3,a1,a2,a3) = sub ~ conv3(a1,a2,a3) : conv4(b0,b1,b2,b3)
with {
  conv3(k0,k1,k2,x)     = k0*x + k1*x' + k2*x'';
  conv4(k0,k1,k2,k3,x)  = k0*x + k1*x' + k2*x'' + k3*x''';
  sub(x,y)              = y-x;
};

//----------------------------- tf4 ---------------------------------
// Fourth-order direct-form digital filter

tf4(b0,b1,b2,b3,b4,a1,a2,a3,a4) = sub ~ conv4(a1,a2,a3,a4) 
                                      : conv5(b0,b1,b2,b3,b4)
with {
  conv4(k0,k1,k2,k3,x)    = k0*x + k1*x' + k2*x'' + k3*x''';
  conv5(k0,k1,k2,k3,k4,x) = k0*x + k1*x' + k2*x'' + k3*x''' + k4*x'''';
  sub(x,y)                = y-x;
};

//----------------------------- wgr ---------------------------------
// Second-order transformer-normalized digital waveguide resonator
// USAGE: wgr(f,r), where
//   f : resonance frequency (Hz)
//   r : loss factor for exponential decay 
//        (set to 1 to make a numerically stable oscillator)
//
// Reference:
// http://ccrma.stanford.edu/~jos/pasp/Digital_Waveguide_Oscillator.html
//
wgr(f,r,x) = (*(G),_<:_,((+:*(C))<:_,_),_:+:+(x),-) ~ cross : _,*(0-gi)
with { 
  C = cos(2*PI*f/SR);
  gi = sqrt((1+C)/(1-C)); // compensate amplitude (only needed when 
  G = r*(1-1' + gi')/gi;  //   frequency changes substantially)
  cross = _,_ <: !,_,_,!;
};

//----------------------------- nlf2 --------------------------------
// Second order normalized digital waveguide resonator
// USAGE: nlf2(f,r), where
//   f : resonance frequency (Hz)
//   r : loss factor for exponential decay 
//        (set to 1 to make a sinusoidal oscillator)
//
// Reference:
// http://ccrma.stanford.edu/~jos/pasp/Power_Normalized_Waveguide_Filters.html
//
nlf2(f,r,x) = ((_<:_,_),(_<:_,_) : (*(s),*(c),*(c),*(0-s)) :> 
              (*(r),+(x))) ~ cross
with { 
  th = 2*PI*f/SR;
  c = cos(th);
  s = sin(th);
  cross = _,_ <: !,_,_,!;
};

//===== Digital Filter Sections Specified as Analog Filter Sections =====
//
//----------------------------- tf2s --------------------------------
// Second-order direct-form digital filter,
// specified by ANALOG transfer-function polynomials B(s)/A(s),
// and a frequency-scaling parameter.  Digitization via the
// bilinear transform is built in.
//
// USAGE: tf2s(b1,b0,a1,a0,w1), where 
//
//            b1 s + b0
// H(s) = -----------------
//         s^2 + a1 s + a0
//
// and w1 is the desired digital frequency (in radians/second)
// corresponding to analog frequency 1 rad/sec (i.e., s = j).
//
// EXAMPLE: A second-order ANALOG Butterworth lowpass filter,
//          normalized to have cutoff frequency at 1 rad/sec,
//          has transfer function
//
//              1
// H(s) = -----------------
//         s^2 + a1 s + 1
//
// where a1 = sqrt(2).  Therefore, a DIGITAL Butterworth lowpass 
// cutting off at SR/4 is specified as tf2s(0,1,sqrt(2),1,PI*SR/2);
//
tf2s(b1,b0,a1,a0,w1) = tf2(b0d,b1d,b2d,a1d,a2d)
with {
  a   = 1/tan((w1)*0.5/SR); // bilinear-transform scale-factor
  asq = a*a;
  d   = a0 + a1*a + asq;
  b0d = (b1 * a + b0)/d;
  b1d = 2*b0/d;
  b2d = (b0 - a * b1)/d;
  a1d = 2 * (a0 - asq)/d;
  a2d = (a0 - a1*a + asq)/d;
};

//----------------------------- tf1s --------------------------------
// First-order direct-form analog filter,
// specified by ANALOG transfer-function polynomials B(s)/A(s),
// and a frequency-scaling parameter.
//
// USAGE: tf1s(b0,a0,w1), where 
//
//           b0
// H(s) = --------
//         s + a0
//
// and w1 is the desired digital frequency (in radians/second)
// corresponding to analog frequency 1 rad/sec (i.e., s = j).
//
// EXAMPLE: A first-order ANALOG Butterworth lowpass filter,
//          normalized to have cutoff frequency at 1 rad/sec,
//          has transfer function
//
//           1
// H(s) = -------
//         s + 1
//
// so b0 = a0 = 1.  Therefore, a DIGITAL first-order Butterworth lowpass 
// with gain -3dB at SR/4 is specified as tf1s(1,1,PI*SR/2);
//
tf1s(b0,a0,w1) = *(b0d) : zero(-1) : (+ ~ *(pole))
with {
  a    = 1/tan((w1)*0.5/SR); // bilinear-transform scale-factor
  d    = a0 + a;
  b0d  = b0 / d;
  pole = (a - a0) / d;
};

//===================== Butterworth Lowpass Filters =====================
//
// Reference: 
// http://ccrma.stanford.edu/~jos/filters/Butterworth_Lowpass_Design.html
//
//----------------------------- lowpass1 -----------------------------
// First-order Butterworth lowpass filter
// USAGE: lowpass1(fc), where 
// fc = desired cut-off frequency (-3dB frequency) in Hz
//
lowpass1(fc) = tf1s(1,1,2*PI*fc);

//----------------------------- lowpass2 ------------------------------
// Second-order Butterworth lowpass filter
// USAGE: lowpass2(fc), where 
// fc = desired cut-off frequency (-3dB frequency) in Hz
//
lowpass2(fc) = tf2s(0,1,sqrt(2),1,2*PI*fc);

//----------------------------- lowpass3 ------------------------------
// Third-order Butterworth lowpass filter
// USAGE: lowpass3(fc), where 
// fc = desired cut-off frequency (-3dB frequency) in Hz
//
lowpass3(fc) = tf2s(0,1,1,1,w1) : tf1s(1,1,w1)
with { w1 = 2*PI*fc; };

//----------------------------- lowpass4 ------------------------------
// Fourth-order Butterworth lowpass filter
// USAGE: lowpass4(fc), where 
// fc = desired cut-off frequency (-3dB frequency) in Hz
//
lowpass4(fc) = tf2s(0,1,a11s,1,w1) : tf2s(0,1,a21s,1,w1)
with {
  a11s = 1.847759065022573; // -2*real(pole1)
  a21s = 0.765366864730180; // -2*real(pole2)
  w1 = 2*PI*fc;
};

//----------------------------- pareq ---------------------------------
// second order Parametric Equalizer section ("peaking equalizer")
// pareq(Q,F,G)
//                      Q : quality factor [1..100]
//                      F :     frequency (Hz)
//                      G : Attenuation (dB) at frequency F (0 elsewhere)
// Adapted from "bandfilter.dsp" in the faust2pd distribution 
// (specifically faust-pd-0.9.9.2 in Planet CCRMA)
// which was released under the BSD license.
//---------------------------------------------------------------------
pareq(Q,F,G) = TF2(  (1 +  K/Q + K*K) / D,
               2 * (K*K - 1)          / D,
              (1 - K/Q + K*K)         / D,
               2 * (K*K - 1)          / D,
              (1 - V*K/Q + K*K)       / D
                       )
with {
              V = db2linear(G);
              K = tan(PI*F/SR);
              D = 1 + V*K/Q + K*K;
};

//========================= Lagrange Interpolation ========================

// Reference:
// http://ccrma.stanford.edu/~jos/pasp/Lagrange_Interpolation.html
// 
//------------------ fdelay1, fdelay2, fdelay3, fdelay4 ---------------
// Delay lines interpolated using Lagrange interpolation
// USAGE: fdelayN(maxdelay, delay, inputsignal) 
//        (exactly like fdelay in music.lib)
// where N=1,2,3, or 4 is the order of the Lagrange interpolation polynomial.
//
// NOTE: requested delay should not be less than (N-1)/2.
//
// NOTE: While the implementations below appear to use multiple delay lines,
//  they in fact use only one thanks to optimization by the Faust compiler.

// first-order case (linear interpolation) - equivalent to fdelay in music.lib
// delay d in [0,1] 
fdelay1(n,d,x)  = delay(n,id,x)*(1 - fd) + delay(n,id+1,x)*fd
with {
  id = int(d);
  fd = frac(d);
};

// second-order (quadratic) case, delay in [0.5,1.5]
// delay d should be at least 0.5
fdelay2(n,d,x) = delay(n,id,x)*(1-fd)*(2-fd)/2 
               + delay(n,id+1,x)*(2-fd)*fd
               + delay(n,id+2,x)*(fd-1)*fd/2
with {
  o = 0.49999; // offset to make life easy for interpolator
  dmo = d - o; // assumed nonnegative
  id = int(dmo);
  fd = o + frac(dmo);
};

// third-order (cubic) case, delay in [1,2]
// delay d should be at least 1
fdelay3(n,d,x) = delay(n,id,x) * (0-fdm1*fdm2*fdm3)/6
               + delay(n,id+1,x) * fd*fdm2*fdm3/2
               + delay(n,id+2,x) * (0-fd*fdm1*fdm3)/2
               + delay(n,id+3,x) * fd*fdm1*fdm2/6
with {
  id = int(d-1); 
  fd = 1+frac(d);
  fdm1 = fd-1;
  fdm2 = fd-2;
  fdm3 = fd-3;
};

// fourth-order (quartic) case, delay in [1.5,2.5]
// delay d should be at least 1.5
fdelay4(n,d,x) = delay(n,id,x)   * fdm1*fdm2*fdm3*fdm4/24 
               + delay(n,id+1,x) * (0-fd*fdm2*fdm3*fdm4)/6
               + delay(n,id+2,x) * fd*fdm1*fdm3*fdm4/4
               + delay(n,id+3,x) * (0-fd*fdm1*fdm2*fdm4)/6
               + delay(n,id+4,x) * fd*fdm1*fdm2*fdm3/24
with {
//v1:  o = 1;
  o = 1.49999;
  dmo = d - o; // assumed nonnegative
  id = int(dmo);
  fd = o + frac(dmo);
  fdm1 = fd-1;
  fdm2 = fd-2;
  fdm3 = fd-3;
  fdm4 = fd-4;
};

//====================== Thiran Allpass Interpolation =====================
//
// Reference:
// http://ccrma.stanford.edu/~jos/pasp/Thiran_Allpass_Interpolators.html
// 
//---------------- fdelay1a, fdelay2a, fdelay3a, fdelay4a -------------
// Delay lines interpolated using Thiran allpass interpolation
// USAGE: fdelayNa(maxdelay, delay, inputsignal) 
//        (exactly like fdelay in music.lib)
// where N=1,2,3, or 4 is the order of the Thiran interpolation filter,
// and the delay argument is at least N - 1/2.
//
// (Move the following and similar notes above to filter-lib-doc.txt?)
//
// NOTE: The interpolated delay should not be less than N - 1/2.
//            (The allpass delay ranges from N - 1/2 to N + 1/2.)
//            This constraint can be alleviated by altering the code,
//            but be aware that allpass filters approach zero delay
//            by means of pole-zero cancellations.
//            The delay range [N-1/2,N+1/2] is not optimal. What is?
//
// NOTE: Delay arguments too small will produce an UNSTABLE allpass!
//
// NOTE: Because allpass interpolation is recursive, it is not as robust
//       as Lagrange interpolation under time-varying conditions.
//       (You may hear clicks when changing the delay rapidly.)
//
// first-order allpass interpolation, allpass delay in [0.5,1.5]
// delay d should be at least 0.5
fdelay1a(n,d,x)  = delay(n,id,x) : tf1(eta,1,eta)
with {
  o = 0.49999; // offset to make life easy for allpass
  dmo = d - o; // assumed nonnegative
  id = int(dmo);
  fd = o + frac(dmo);
  eta = (1-fd)/(1+fd); // allpass coefficient
};

// second-order allpass delay in [1.5,2.5]
// delay d should be at least 1.5
fdelay2a(n,d,x) = delay(n,id,x) : tf2(a2,a1,1,a1,a2)
with {
  o = 1.49999;
  dmo = d - o; // delay range is [order-1/2, order+1/2]
  id = int(dmo);
  fd = o + frac(dmo);
  a1o2 = (2-fd)/(1+fd); // share some terms (the compiler does this anyway)
  a1 = 2*a1o2;
  a2 = a1o2*(1-fd)/(2+fd);
};

// third-order allpass delay in [2.5,3.5]
// delay d should be at least 2.5
fdelay3a(n,d,x) = delay(n,id,x) : tf3(a3,a2,a1,1,a1,a2,a3)
with {
  o = 2.49999;
  dmo = d - o;
  id = int(dmo);
  fd = o + frac(dmo);
  a1o3 = (3-fd)/(1+fd);
  a2o3 = a1o3*(2-fd)/(2+fd);
  a1 = 3*a1o3;
  a2 = 3*a2o3;
  a3 = a2o3*(1-fd)/(3+fd);
};

// fourth-order allpass delay in [3.5,3.5]
// delay d should be at least 3.5
fdelay4a(n,d,x) = delay(n,id,x) : tf4(a4,a3,a2,a1,1,a1,a2,a3,a4)
with {
  o = 3.49999;
  dmo = d - o;
  id = int(dmo);
  fd = o + frac(dmo);
  a1o4 = (4-fd)/(1+fd);
  a2o6 = a1o4*(3-fd)/(2+fd);
  a3o4 = a2o6*(2-fd)/(3+fd);
  a1 = 4*a1o4;
  a2 = 6*a2o6;
  a3 = 4*a3o4;
  a4 = a3o4*(1-fd)/(4+fd);
};
